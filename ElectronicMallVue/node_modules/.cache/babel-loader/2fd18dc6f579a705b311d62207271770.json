{"ast":null,"code":"import _classCallCheck from \"D:/Workspace/graduation_project/ElectronicMall/ElectronicMallVue/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"D:/Workspace/graduation_project/ElectronicMall/ElectronicMallVue/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/web.dom-collections.for-each.js\";\nimport \"core-js/modules/es.array.fill.js\";\nimport { drawShapes } from './shapes';\nimport { handleCollision } from './utils';\nimport { AStarPathfinder } from './pathfinder';\nexport var CanvasRenderer = /*#__PURE__*/function () {\n  function CanvasRenderer(vm, canvasId) {\n    _classCallCheck(this, CanvasRenderer);\n\n    this.vm = vm;\n    this.canvas = document.getElementById(canvasId);\n    this.ctx = this.canvas.getContext('2d');\n    this.animationFrame = null;\n    this.pathfinder = new AStarPathfinder(Math.floor(vm.canvasWidth / vm.gridSize), Math.floor(vm.canvasHeight / vm.gridSize));\n    this.currentPath = [];\n  }\n\n  _createClass(CanvasRenderer, [{\n    key: \"init\",\n    value: function init() {\n      this.drawGrid();\n      this.drawAllElements();\n    }\n  }, {\n    key: \"updatePath\",\n    value: function updatePath(start, end) {\n      this.pathfinder.setObstacles(this.vm.currentFloorObstacles);\n      this.currentPath = this.pathfinder.findPath(start, end) || [];\n      console.log('计算得到的路径:', this.currentPath); // 打印路径检查是否正确\n    }\n  }, {\n    key: \"drawPath\",\n    value: function drawPath() {\n      if (this.currentPath.length === 0) return;\n      var ctx = this.ctx,\n          gridSize = this.vm.gridSize;\n      ctx.beginPath();\n      ctx.strokeStyle = '#ff0000';\n      ctx.lineWidth = 2;\n      this.currentPath.forEach(function (point, index) {\n        var x = (point.x + 0.5) * gridSize;\n        var y = (point.y + 0.5) * gridSize;\n\n        if (index === 0) {\n          ctx.moveTo(x, y);\n        } else {\n          ctx.lineTo(x, y);\n        }\n      });\n      ctx.stroke(); // 绘制路径点\n\n      ctx.fillStyle = '#00ff00';\n      this.currentPath.forEach(function (point) {\n        ctx.beginPath();\n        ctx.arc((point.x + 0.5) * gridSize, (point.y + 0.5) * gridSize, 3, 0, Math.PI * 2);\n        ctx.fill();\n      });\n    }\n  }, {\n    key: \"drawColoredGrid\",\n    value: function drawColoredGrid(x, y, color) {\n      var gridSize = this.vm.gridSize;\n      var startX = x * gridSize;\n      var startY = y * gridSize;\n      this.ctx.fillStyle = color;\n      this.ctx.fillRect(startX, startY, gridSize, gridSize);\n    }\n  }, {\n    key: \"drawGrid\",\n    value: function drawGrid() {\n      var ctx = this.ctx,\n          _this$vm = this.vm,\n          gridSize = _this$vm.gridSize,\n          canvasWidth = _this$vm.canvasWidth,\n          canvasHeight = _this$vm.canvasHeight;\n      ctx.strokeStyle = 'gray';\n      ctx.lineWidth = 1; // 绘制横向网格线\n\n      for (var y = 0; y <= canvasHeight; y += gridSize) {\n        ctx.beginPath();\n        ctx.moveTo(0, y);\n        ctx.lineTo(canvasWidth, y);\n        ctx.stroke();\n      } // 绘制纵向网格线\n\n\n      for (var x = 0; x <= canvasWidth; x += gridSize) {\n        ctx.beginPath();\n        ctx.moveTo(x, 0);\n        ctx.lineTo(x, canvasHeight);\n        ctx.stroke();\n      }\n    }\n  }, {\n    key: \"loadSecondFloor\",\n    value: function loadSecondFloor() {\n      this.vm.currentFloor = '二楼';\n      this.vm.blockX = 0;\n      this.vm.blockY = 0;\n      this.vm.pathEnd = null;\n      this.currentPath = [];\n      this.drawAllElements();\n    }\n  }, {\n    key: \"loadFirstFloor\",\n    value: function loadFirstFloor() {\n      this.vm.currentFloor = '一楼';\n      this.vm.blockX = 0;\n      this.vm.blockY = 0;\n      this.vm.pathEnd = null;\n      this.currentPath = [];\n      this.drawAllElements();\n    }\n  }, {\n    key: \"drawAllElements\",\n    value: function drawAllElements() {\n      var _this = this;\n\n      var ctx = this.ctx,\n          vm = this.vm;\n      ctx.clearRect(0, 0, vm.canvasWidth, vm.canvasHeight);\n      this.drawGrid();\n      this.drawShops();\n      this.drawObstacles();\n      this.drawPlayer();\n      this.drawPath();\n\n      if (vm.pathStart) {\n        this.drawColoredGrid(vm.pathStart.x, vm.pathStart.y, 'blue');\n      }\n\n      if (vm.pathEnd) {\n        this.drawColoredGrid(vm.pathEnd.x, vm.pathEnd.y, 'red');\n      }\n\n      this.animationFrame = requestAnimationFrame(function () {\n        return _this.drawAllElements();\n      });\n    }\n  }, {\n    key: \"drawShops\",\n    value: function drawShops() {\n      var _this2 = this;\n\n      var _this$vm2 = this.vm,\n          shops = _this$vm2.currentFloorShops,\n          gridSize = _this$vm2.gridSize;\n      shops.forEach(function (shop) {\n        return drawShapes[shop.shape](_this2.ctx, shop, gridSize);\n      });\n    }\n  }, {\n    key: \"drawObstacles\",\n    value: function drawObstacles() {\n      var _this3 = this;\n\n      var _this$vm3 = this.vm,\n          obstacles = _this$vm3.currentFloorObstacles,\n          gridSize = _this$vm3.gridSize,\n          treeImage = _this$vm3.treeImage;\n      obstacles.forEach(function (obs) {\n        if (treeImage.complete) {\n          _this3.ctx.drawImage(treeImage, obs.x * gridSize, obs.y * gridSize, gridSize, gridSize);\n        }\n      });\n    }\n  }, {\n    key: \"drawPlayer\",\n    value: function drawPlayer() {\n      var ctx = this.ctx,\n          _this$vm4 = this.vm,\n          blockX = _this$vm4.blockX,\n          blockY = _this$vm4.blockY,\n          gridSize = _this$vm4.gridSize;\n      ctx.fillStyle = 'red';\n      ctx.fillRect(blockX * gridSize, blockY * gridSize, gridSize, gridSize);\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      cancelAnimationFrame(this.animationFrame);\n    }\n  }]);\n\n  return CanvasRenderer;\n}();","map":{"version":3,"sources":["D:/Workspace/graduation_project/ElectronicMall/ElectronicMallVue/src/views/front/mall/canvasRenderer/index.js"],"names":["drawShapes","handleCollision","AStarPathfinder","CanvasRenderer","vm","canvasId","canvas","document","getElementById","ctx","getContext","animationFrame","pathfinder","Math","floor","canvasWidth","gridSize","canvasHeight","currentPath","drawGrid","drawAllElements","start","end","setObstacles","currentFloorObstacles","findPath","console","log","length","beginPath","strokeStyle","lineWidth","forEach","point","index","x","y","moveTo","lineTo","stroke","fillStyle","arc","PI","fill","color","startX","startY","fillRect","currentFloor","blockX","blockY","pathEnd","clearRect","drawShops","drawObstacles","drawPlayer","drawPath","pathStart","drawColoredGrid","requestAnimationFrame","shops","currentFloorShops","shop","shape","obstacles","treeImage","obs","complete","drawImage","cancelAnimationFrame"],"mappings":"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","sourcesContent":["import { drawShapes } from './shapes';\nimport { handleCollision } from './utils';\nimport { AStarPathfinder } from './pathfinder';\n\nexport class CanvasRenderer {\n  constructor(vm, canvasId) {\n    this.vm = vm;\n    this.canvas = document.getElementById(canvasId);\n    this.ctx = this.canvas.getContext('2d');\n    this.animationFrame = null;\n    this.pathfinder = new AStarPathfinder(\n      Math.floor(vm.canvasWidth / vm.gridSize),\n      Math.floor(vm.canvasHeight / vm.gridSize)\n    );\n    this.currentPath = [];\n  }\n\n  init() {\n    this.drawGrid();\n    this.drawAllElements(); \n  }\n  updatePath(start, end) {\n    this.pathfinder.setObstacles(this.vm.currentFloorObstacles);\n    this.currentPath = this.pathfinder.findPath(start, end) || [];\n    console.log('计算得到的路径:', this.currentPath); // 打印路径检查是否正确\n  }\n\n  drawPath() {\n    if (this.currentPath.length === 0) return;\n\n    const { ctx, vm: { gridSize } } = this;\n    ctx.beginPath();\n    ctx.strokeStyle = '#ff0000';\n    ctx.lineWidth = 2;\n\n    this.currentPath.forEach((point, index) => {\n      const x = (point.x + 0.5) * gridSize;\n      const y = (point.y + 0.5) * gridSize;\n      \n      if (index === 0) {\n        ctx.moveTo(x, y);\n      } else {\n        ctx.lineTo(x, y);\n      }\n    });\n    ctx.stroke();\n    \n    // 绘制路径点\n    ctx.fillStyle = '#00ff00';\n    this.currentPath.forEach(point => {\n      ctx.beginPath();\n      ctx.arc(\n        (point.x + 0.5) * gridSize,\n        (point.y + 0.5) * gridSize,\n        3, 0, Math.PI * 2\n      );\n      ctx.fill();\n    });\n  }\n  drawColoredGrid(x, y, color) {\n    const gridSize = this.vm.gridSize;\n    const startX = x * gridSize;\n    const startY = y * gridSize;\n    this.ctx.fillStyle = color;\n    this.ctx.fillRect(startX, startY, gridSize, gridSize);\n  }\n\n  drawGrid() {\n    const { ctx, vm: { gridSize, canvasWidth, canvasHeight } } = this;\n    ctx.strokeStyle = 'gray';\n    ctx.lineWidth = 1;\n\n    // 绘制横向网格线\n    for (let y = 0; y <= canvasHeight; y += gridSize) {\n      ctx.beginPath();\n      ctx.moveTo(0, y);\n      ctx.lineTo(canvasWidth, y);\n      ctx.stroke();\n    }\n\n    // 绘制纵向网格线\n    for (let x = 0; x <= canvasWidth; x += gridSize) {\n      ctx.beginPath();\n      ctx.moveTo(x, 0);\n      ctx.lineTo(x, canvasHeight);\n      ctx.stroke();\n    }\n  }\n\n  loadSecondFloor () {\n    this.vm.currentFloor = '二楼';\n    this.vm.blockX = 0;\n    this.vm.blockY = 0;\n    this.vm.pathEnd = null;\n    this.currentPath = [];\n    this.drawAllElements();\n  };\n\n  \n  loadFirstFloor () {\n    this.vm.currentFloor = '一楼';\n    this.vm.blockX = 0;\n    this.vm.blockY = 0;\n    this.vm.pathEnd = null;\n    this.currentPath = [];\n    this.drawAllElements();\n  };\n\n  drawAllElements() {\n    const { ctx, vm } = this;\n    ctx.clearRect(0, 0, vm.canvasWidth, vm.canvasHeight);\n    \n    this.drawGrid();\n    this.drawShops();\n    this.drawObstacles();\n    this.drawPlayer();\n    this.drawPath();\n\n    if (vm.pathStart) {\n      this.drawColoredGrid(vm.pathStart.x, vm.pathStart.y, 'blue');\n    }\n    if (vm.pathEnd) {\n      this.drawColoredGrid(vm.pathEnd.x, vm.pathEnd.y, 'red');\n    }\n    \n    this.animationFrame = requestAnimationFrame(() => this.drawAllElements());\n  }\n\n  drawShops() {\n    const { currentFloorShops: shops, gridSize } = this.vm;\n    shops.forEach(shop => drawShapes[shop.shape](this.ctx, shop, gridSize));\n  }\n\n  drawObstacles() {\n    const { currentFloorObstacles: obstacles, gridSize, treeImage } = this.vm;\n    obstacles.forEach(obs => {\n      if (treeImage.complete) {\n        this.ctx.drawImage(treeImage, obs.x * gridSize, obs.y * gridSize, gridSize, gridSize);\n      }\n    });\n  }\n\n  drawPlayer() {\n    const { ctx, vm: { blockX, blockY, gridSize } } = this;\n    ctx.fillStyle = 'red';\n    ctx.fillRect(blockX * gridSize, blockY * gridSize, gridSize, gridSize);\n  }\n\n  destroy() {\n    cancelAnimationFrame(this.animationFrame);\n  }\n}"]},"metadata":{},"sourceType":"module"}