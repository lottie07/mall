{"ast":null,"code":"import _classCallCheck from \"D:/Workspace/graduation_project/ElectronicMall/ElectronicMallVue/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"D:/Workspace/graduation_project/ElectronicMall/ElectronicMallVue/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/web.dom-collections.for-each.js\";\nimport \"core-js/modules/es.array.fill.js\";\nimport { drawShapes } from './shapes';\nimport { handleCollision } from './utils';\nimport { AStarPathfinder } from './pathfinder';\nexport var CanvasRenderer = /*#__PURE__*/function () {\n  function CanvasRenderer(vm, canvasId) {\n    _classCallCheck(this, CanvasRenderer);\n\n    this.vm = vm;\n    this.canvas = document.getElementById(canvasId);\n    this.ctx = this.canvas.getContext('2d');\n    this.animationFrame = null;\n    this.pathfinder = new AStarPathfinder(Math.floor(vm.canvasWidth / vm.gridSize), Math.floor(vm.canvasHeight / vm.gridSize));\n    this.currentPath = [];\n  }\n\n  _createClass(CanvasRenderer, [{\n    key: \"init\",\n    value: function init() {\n      this.drawGrid();\n      this.drawAllElements();\n    }\n  }, {\n    key: \"updatePath\",\n    value: function updatePath(start, end) {\n      this.pathfinder.setObstacles(this.vm.currentFloorObstacles);\n      this.currentPath = this.pathfinder.findPath(start, end) || [];\n    }\n  }, {\n    key: \"drawPath\",\n    value: function drawPath() {\n      if (this.currentPath.length === 0) return;\n      var ctx = this.ctx,\n          gridSize = this.vm.gridSize;\n      ctx.beginPath();\n      ctx.strokeStyle = '#ff0000';\n      ctx.lineWidth = 2;\n      this.currentPath.forEach(function (point, index) {\n        var x = (point.x + 0.5) * gridSize;\n        var y = (point.y + 0.5) * gridSize;\n\n        if (index === 0) {\n          ctx.moveTo(x, y);\n        } else {\n          ctx.lineTo(x, y);\n        }\n      });\n      ctx.stroke(); // 绘制路径点\n\n      ctx.fillStyle = '#00ff00';\n      this.currentPath.forEach(function (point) {\n        ctx.beginPath();\n        ctx.arc((point.x + 0.5) * gridSize, (point.y + 0.5) * gridSize, 3, 0, Math.PI * 2);\n        ctx.fill();\n      });\n    }\n  }, {\n    key: \"drawColoredGrid\",\n    value: function drawColoredGrid(x, y, color) {\n      var gridSize = this.vm.gridSize;\n      var startX = x * gridSize;\n      var startY = y * gridSize;\n      this.ctx.fillStyle = color;\n      this.ctx.fillRect(startX, startY, gridSize, gridSize);\n    }\n  }, {\n    key: \"drawGrid\",\n    value: function drawGrid() {\n      var ctx = this.ctx,\n          _this$vm = this.vm,\n          gridSize = _this$vm.gridSize,\n          canvasWidth = _this$vm.canvasWidth,\n          canvasHeight = _this$vm.canvasHeight;\n      ctx.strokeStyle = 'gray';\n      ctx.lineWidth = 1; // 绘制横向网格线\n\n      for (var y = 0; y <= canvasHeight; y += gridSize) {\n        ctx.beginPath();\n        ctx.moveTo(0, y);\n        ctx.lineTo(canvasWidth, y);\n        ctx.stroke();\n      } // 绘制纵向网格线\n\n\n      for (var x = 0; x <= canvasWidth; x += gridSize) {\n        ctx.beginPath();\n        ctx.moveTo(x, 0);\n        ctx.lineTo(x, canvasHeight);\n        ctx.stroke();\n      }\n    }\n  }, {\n    key: \"drawAllElements\",\n    value: function drawAllElements() {\n      var _this = this;\n\n      var ctx = this.ctx,\n          vm = this.vm;\n      ctx.clearRect(0, 0, vm.canvasWidth, vm.canvasHeight);\n      this.drawGrid();\n      this.drawShops();\n      this.drawObstacles();\n      this.drawPlayer();\n      this.drawPath();\n      this.animationFrame = requestAnimationFrame(function () {\n        return _this.drawAllElements();\n      });\n    }\n  }, {\n    key: \"drawShops\",\n    value: function drawShops() {\n      var _this2 = this;\n\n      var _this$vm2 = this.vm,\n          shops = _this$vm2.currentFloorShops,\n          gridSize = _this$vm2.gridSize;\n      shops.forEach(function (shop) {\n        return drawShapes[shop.shape](_this2.ctx, shop, gridSize);\n      });\n    }\n  }, {\n    key: \"drawObstacles\",\n    value: function drawObstacles() {\n      var _this3 = this;\n\n      var _this$vm3 = this.vm,\n          obstacles = _this$vm3.currentFloorObstacles,\n          gridSize = _this$vm3.gridSize,\n          treeImage = _this$vm3.treeImage;\n      obstacles.forEach(function (obs) {\n        if (treeImage.complete) {\n          _this3.ctx.drawImage(treeImage, obs.x * gridSize, obs.y * gridSize, gridSize, gridSize);\n        }\n      });\n    }\n  }, {\n    key: \"drawPlayer\",\n    value: function drawPlayer() {\n      var ctx = this.ctx,\n          _this$vm4 = this.vm,\n          blockX = _this$vm4.blockX,\n          blockY = _this$vm4.blockY,\n          gridSize = _this$vm4.gridSize;\n      ctx.fillStyle = 'red';\n      ctx.fillRect(blockX * gridSize, blockY * gridSize, gridSize, gridSize);\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      cancelAnimationFrame(this.animationFrame);\n    }\n  }]);\n\n  return CanvasRenderer;\n}();","map":{"version":3,"sources":["D:/Workspace/graduation_project/ElectronicMall/ElectronicMallVue/src/views/front/mall/canvasRenderer/index.js"],"names":["drawShapes","handleCollision","AStarPathfinder","CanvasRenderer","vm","canvasId","canvas","document","getElementById","ctx","getContext","animationFrame","pathfinder","Math","floor","canvasWidth","gridSize","canvasHeight","currentPath","drawGrid","drawAllElements","start","end","setObstacles","currentFloorObstacles","findPath","length","beginPath","strokeStyle","lineWidth","forEach","point","index","x","y","moveTo","lineTo","stroke","fillStyle","arc","PI","fill","color","startX","startY","fillRect","clearRect","drawShops","drawObstacles","drawPlayer","drawPath","requestAnimationFrame","shops","currentFloorShops","shop","shape","obstacles","treeImage","obs","complete","drawImage","blockX","blockY","cancelAnimationFrame"],"mappings":"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","sourcesContent":["import { drawShapes } from './shapes';\nimport { handleCollision } from './utils';\nimport { AStarPathfinder } from './pathfinder';\n\nexport class CanvasRenderer {\n  constructor(vm, canvasId) {\n    this.vm = vm;\n    this.canvas = document.getElementById(canvasId);\n    this.ctx = this.canvas.getContext('2d');\n    this.animationFrame = null;\n    this.pathfinder = new AStarPathfinder(\n      Math.floor(vm.canvasWidth / vm.gridSize),\n      Math.floor(vm.canvasHeight / vm.gridSize)\n    );\n    this.currentPath = [];\n  }\n\n  init() {\n    this.drawGrid();\n    this.drawAllElements(); \n  }\n  updatePath(start, end) {\n    this.pathfinder.setObstacles(this.vm.currentFloorObstacles);\n    this.currentPath = this.pathfinder.findPath(start, end) || [];\n  }\n\n  drawPath() {\n    if (this.currentPath.length === 0) return;\n\n    const { ctx, vm: { gridSize } } = this;\n    ctx.beginPath();\n    ctx.strokeStyle = '#ff0000';\n    ctx.lineWidth = 2;\n\n    this.currentPath.forEach((point, index) => {\n      const x = (point.x + 0.5) * gridSize;\n      const y = (point.y + 0.5) * gridSize;\n      \n      if (index === 0) {\n        ctx.moveTo(x, y);\n      } else {\n        ctx.lineTo(x, y);\n      }\n    });\n    ctx.stroke();\n    \n    // 绘制路径点\n    ctx.fillStyle = '#00ff00';\n    this.currentPath.forEach(point => {\n      ctx.beginPath();\n      ctx.arc(\n        (point.x + 0.5) * gridSize,\n        (point.y + 0.5) * gridSize,\n        3, 0, Math.PI * 2\n      );\n      ctx.fill();\n    });\n  }\n  drawColoredGrid(x, y, color) {\n    const gridSize = this.vm.gridSize;\n    const startX = x * gridSize;\n    const startY = y * gridSize;\n    this.ctx.fillStyle = color;\n    this.ctx.fillRect(startX, startY, gridSize, gridSize);\n  }\n\n  drawGrid() {\n    const { ctx, vm: { gridSize, canvasWidth, canvasHeight } } = this;\n    ctx.strokeStyle = 'gray';\n    ctx.lineWidth = 1;\n\n    // 绘制横向网格线\n    for (let y = 0; y <= canvasHeight; y += gridSize) {\n      ctx.beginPath();\n      ctx.moveTo(0, y);\n      ctx.lineTo(canvasWidth, y);\n      ctx.stroke();\n    }\n\n    // 绘制纵向网格线\n    for (let x = 0; x <= canvasWidth; x += gridSize) {\n      ctx.beginPath();\n      ctx.moveTo(x, 0);\n      ctx.lineTo(x, canvasHeight);\n      ctx.stroke();\n    }\n  }\n\n  drawAllElements() {\n    const { ctx, vm } = this;\n    ctx.clearRect(0, 0, vm.canvasWidth, vm.canvasHeight);\n    \n    this.drawGrid();\n    this.drawShops();\n    this.drawObstacles();\n    this.drawPlayer();\n    this.drawPath();\n    \n    this.animationFrame = requestAnimationFrame(() => this.drawAllElements());\n  }\n\n  drawShops() {\n    const { currentFloorShops: shops, gridSize } = this.vm;\n    shops.forEach(shop => drawShapes[shop.shape](this.ctx, shop, gridSize));\n  }\n\n  drawObstacles() {\n    const { currentFloorObstacles: obstacles, gridSize, treeImage } = this.vm;\n    obstacles.forEach(obs => {\n      if (treeImage.complete) {\n        this.ctx.drawImage(treeImage, obs.x * gridSize, obs.y * gridSize, gridSize, gridSize);\n      }\n    });\n  }\n\n  drawPlayer() {\n    const { ctx, vm: { blockX, blockY, gridSize } } = this;\n    ctx.fillStyle = 'red';\n    ctx.fillRect(blockX * gridSize, blockY * gridSize, gridSize, gridSize);\n  }\n\n  destroy() {\n    cancelAnimationFrame(this.animationFrame);\n  }\n}"]},"metadata":{},"sourceType":"module"}