{"ast":null,"code":"import _classCallCheck from \"D:/Workspace/graduation_project/ElectronicMall/ElectronicMallVue/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"D:/Workspace/graduation_project/ElectronicMall/ElectronicMallVue/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/web.dom-collections.for-each.js\";\nimport { drawShapes } from './shapes';\nimport { handleCollision } from './utils';\nimport { AStarPathfinder } from './pathfinder';\nexport var CanvasRenderer = /*#__PURE__*/function () {\n  function CanvasRenderer(vm, canvasId) {\n    _classCallCheck(this, CanvasRenderer);\n\n    this.vm = vm;\n    this.canvas = document.getElementById(canvasId);\n    this.ctx = this.canvas.getContext('2d');\n    this.animationFrame = null;\n    this.pathfinder = new AStarPathfinder(Math.floor(vm.canvasWidth / vm.gridSize), Math.floor(vm.canvasHeight / vm.gridSize));\n    this.currentPath = [];\n  }\n\n  _createClass(CanvasRenderer, [{\n    key: \"init\",\n    value: function init() {\n      this.drawGrid();\n      this.drawAllElements();\n    }\n  }, {\n    key: \"drawGrid\",\n    value: function drawGrid() {\n      var ctx = this.ctx,\n          _this$vm = this.vm,\n          gridSize = _this$vm.gridSize,\n          canvasWidth = _this$vm.canvasWidth,\n          canvasHeight = _this$vm.canvasHeight;\n      ctx.strokeStyle = 'gray';\n      ctx.lineWidth = 1; // 绘制横向网格线\n\n      for (var y = 0; y <= canvasHeight; y += gridSize) {\n        ctx.beginPath();\n        ctx.moveTo(0, y);\n        ctx.lineTo(canvasWidth, y);\n        ctx.stroke();\n      } // 绘制纵向网格线\n\n\n      for (var x = 0; x <= canvasWidth; x += gridSize) {\n        ctx.beginPath();\n        ctx.moveTo(x, 0);\n        ctx.lineTo(x, canvasHeight);\n        ctx.stroke();\n      }\n    }\n  }, {\n    key: \"drawAllElements\",\n    value: function drawAllElements() {\n      var _this = this;\n\n      var ctx = this.ctx,\n          vm = this.vm;\n      ctx.clearRect(0, 0, vm.canvasWidth, vm.canvasHeight);\n      this.drawGrid();\n      this.drawShops();\n      this.drawObstacles();\n      this.drawPlayer();\n      this.animationFrame = requestAnimationFrame(function () {\n        return _this.drawAllElements();\n      });\n    }\n  }, {\n    key: \"drawShops\",\n    value: function drawShops() {\n      var _this2 = this;\n\n      var _this$vm2 = this.vm,\n          shops = _this$vm2.currentFloorShops,\n          gridSize = _this$vm2.gridSize;\n      shops.forEach(function (shop) {\n        return drawShapes[shop.shape](_this2.ctx, shop, gridSize);\n      });\n    }\n  }, {\n    key: \"drawObstacles\",\n    value: function drawObstacles() {\n      var _this3 = this;\n\n      var _this$vm3 = this.vm,\n          obstacles = _this$vm3.currentFloorObstacles,\n          gridSize = _this$vm3.gridSize,\n          treeImage = _this$vm3.treeImage;\n      obstacles.forEach(function (obs) {\n        if (treeImage.complete) {\n          _this3.ctx.drawImage(treeImage, obs.x * gridSize, obs.y * gridSize, gridSize, gridSize);\n        }\n      });\n    }\n  }, {\n    key: \"drawPlayer\",\n    value: function drawPlayer() {\n      var ctx = this.ctx,\n          _this$vm4 = this.vm,\n          blockX = _this$vm4.blockX,\n          blockY = _this$vm4.blockY,\n          gridSize = _this$vm4.gridSize;\n      ctx.fillStyle = 'red';\n      ctx.fillRect(blockX * gridSize, blockY * gridSize, gridSize, gridSize);\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      cancelAnimationFrame(this.animationFrame);\n    }\n  }]);\n\n  return CanvasRenderer;\n}();","map":{"version":3,"sources":["D:/Workspace/graduation_project/ElectronicMall/ElectronicMallVue/src/views/front/mall/canvasRenderer/index.js"],"names":["drawShapes","handleCollision","AStarPathfinder","CanvasRenderer","vm","canvasId","canvas","document","getElementById","ctx","getContext","animationFrame","pathfinder","Math","floor","canvasWidth","gridSize","canvasHeight","currentPath","drawGrid","drawAllElements","strokeStyle","lineWidth","y","beginPath","moveTo","lineTo","stroke","x","clearRect","drawShops","drawObstacles","drawPlayer","requestAnimationFrame","shops","currentFloorShops","forEach","shop","shape","obstacles","currentFloorObstacles","treeImage","obs","complete","drawImage","blockX","blockY","fillStyle","fillRect","cancelAnimationFrame"],"mappings":"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","sourcesContent":["import { drawShapes } from './shapes';\nimport { handleCollision } from './utils';\nimport { AStarPathfinder } from './pathfinder';\n\nexport class CanvasRenderer {\n  constructor(vm, canvasId) {\n    this.vm = vm;\n    this.canvas = document.getElementById(canvasId);\n    this.ctx = this.canvas.getContext('2d');\n    this.animationFrame = null;\n    this.pathfinder = new AStarPathfinder(\n      Math.floor(vm.canvasWidth / vm.gridSize),\n      Math.floor(vm.canvasHeight / vm.gridSize)\n    );\n    this.currentPath = [];\n  }\n\n  init() {\n    this.drawGrid();\n    this.drawAllElements();\n  }\n\n  drawGrid() {\n    const { ctx, vm: { gridSize, canvasWidth, canvasHeight } } = this;\n    ctx.strokeStyle = 'gray';\n    ctx.lineWidth = 1;\n\n    // 绘制横向网格线\n    for (let y = 0; y <= canvasHeight; y += gridSize) {\n      ctx.beginPath();\n      ctx.moveTo(0, y);\n      ctx.lineTo(canvasWidth, y);\n      ctx.stroke();\n    }\n\n    // 绘制纵向网格线\n    for (let x = 0; x <= canvasWidth; x += gridSize) {\n      ctx.beginPath();\n      ctx.moveTo(x, 0);\n      ctx.lineTo(x, canvasHeight);\n      ctx.stroke();\n    }\n  }\n\n  drawAllElements() {\n    const { ctx, vm } = this;\n    ctx.clearRect(0, 0, vm.canvasWidth, vm.canvasHeight);\n    \n    this.drawGrid();\n    this.drawShops();\n    this.drawObstacles();\n    this.drawPlayer();\n    \n    this.animationFrame = requestAnimationFrame(() => this.drawAllElements());\n  }\n\n  drawShops() {\n    const { currentFloorShops: shops, gridSize } = this.vm;\n    shops.forEach(shop => drawShapes[shop.shape](this.ctx, shop, gridSize));\n  }\n\n  drawObstacles() {\n    const { currentFloorObstacles: obstacles, gridSize, treeImage } = this.vm;\n    obstacles.forEach(obs => {\n      if (treeImage.complete) {\n        this.ctx.drawImage(treeImage, obs.x * gridSize, obs.y * gridSize, gridSize, gridSize);\n      }\n    });\n  }\n\n  drawPlayer() {\n    const { ctx, vm: { blockX, blockY, gridSize } } = this;\n    ctx.fillStyle = 'red';\n    ctx.fillRect(blockX * gridSize, blockY * gridSize, gridSize, gridSize);\n  }\n\n  destroy() {\n    cancelAnimationFrame(this.animationFrame);\n  }\n}"]},"metadata":{},"sourceType":"module"}