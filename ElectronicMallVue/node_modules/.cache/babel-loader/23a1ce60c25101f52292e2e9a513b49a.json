{"ast":null,"code":"import _toConsumableArray from \"D:/Workspace/graduation_project/ElectronicMall/ElectronicMallVue/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _slicedToArray from \"D:/Workspace/graduation_project/ElectronicMall/ElectronicMallVue/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _classCallCheck from \"D:/Workspace/graduation_project/ElectronicMall/ElectronicMallVue/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"D:/Workspace/graduation_project/ElectronicMall/ElectronicMallVue/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport \"core-js/modules/es.map.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.string.iterator.js\";\nimport \"core-js/modules/web.dom-collections.iterator.js\";\nimport \"core-js/modules/web.dom-collections.for-each.js\";\nimport \"core-js/modules/es.regexp.exec.js\";\nimport \"core-js/modules/es.string.split.js\";\nimport \"core-js/modules/es.array.concat.js\";\nimport \"core-js/modules/es.array.from.js\";\nimport \"core-js/modules/es.array.sort.js\";\nexport var GraphNetwork = /*#__PURE__*/function () {\n  function GraphNetwork() {\n    _classCallCheck(this, GraphNetwork);\n\n    this.nodes = new Map(); // 存储节点 {x, y}\n\n    this.edges = new Map(); // 存储边数据\n\n    this.adjacencyList = new Map(); // 邻接表\n  }\n\n  _createClass(GraphNetwork, [{\n    key: \"_nodeEquals\",\n    value: function _nodeEquals(a, b) {\n      return a.x === b.x && a.y === b.y;\n    }\n  }, {\n    key: \"validate\",\n    value: function validate() {\n      var _this = this;\n\n      var isValid = true;\n      this.edges.forEach(function (_, key) {\n        var _this$adjacencyList$g, _this$adjacencyList$g2;\n\n        var _key$split = key.split('-'),\n            _key$split2 = _slicedToArray(_key$split, 2),\n            a = _key$split2[0],\n            b = _key$split2[1];\n\n        if (!((_this$adjacencyList$g = _this.adjacencyList.get(a)) !== null && _this$adjacencyList$g !== void 0 && _this$adjacencyList$g.some(function (n) {\n          return n.node === b;\n        }))) {\n          console.error(\"\\u8FB9 \".concat(key, \" \\u4E0D\\u5B58\\u5728\\u4E8E\\u90BB\\u63A5\\u8868\"));\n          isValid = false;\n        }\n\n        if (!((_this$adjacencyList$g2 = _this.adjacencyList.get(b)) !== null && _this$adjacencyList$g2 !== void 0 && _this$adjacencyList$g2.some(function (n) {\n          return n.node === a;\n        }))) {\n          console.error(\"\\u53CD\\u5411\\u8FB9 \".concat(key, \" \\u4E0D\\u5B58\\u5728\\u4E8E\\u90BB\\u63A5\\u8868\"));\n          isValid = false;\n        }\n      }); // 验证节点坐标有效性\n\n      this.nodes.forEach(function (node, key) {\n        if (key !== \"\".concat(node.x, \",\").concat(node.y)) {\n          console.error(\"\\u8282\\u70B9\\u5750\\u6807\\u4E0D\\u5339\\u914D: \".concat(key, \" vs \").concat(node.x, \",\").concat(node.y));\n          isValid = false;\n        }\n      });\n      return isValid;\n    } // 添加节点\n\n  }, {\n    key: \"addNode\",\n    value: function addNode(point) {\n      var key = this._nodeKey(point);\n\n      if (!this.nodes.has(key)) {\n        this.nodes.set(key, {\n          x: point.x,\n          y: point.y\n        });\n        this.adjacencyList.set(key, []);\n      }\n    } // 构建网络（同步版本）\n\n  }, {\n    key: \"buildNetwork\",\n    value: function buildNetwork(shopPoints) {\n      var _this2 = this;\n\n      var maxConnectionDistance = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 10;\n      this.clearNetwork(); // 添加所有节点\n\n      shopPoints.forEach(function (shop) {\n        _this2.addNode({\n          x: Math.floor(shop.centerX),\n          y: Math.floor(shop.centerY)\n        });\n      });\n      var nodeList = Array.from(this.nodes.values());\n\n      for (var i = 0; i < nodeList.length; i++) {\n        var hasEdge = false;\n\n        for (var j = i + 1; j < nodeList.length; j++) {\n          var nodeA = nodeList[i];\n          var nodeB = nodeList[j];\n\n          if (this._distance(nodeA, nodeB) <= maxConnectionDistance) {\n            this._createEdge(nodeA, nodeB);\n\n            hasEdge = true;\n          }\n        } // 如果当前点没有边，则强制与第一个点连接\n\n\n        if (!hasEdge && nodeList.length > 1) {\n          var Node = nodeList[40];\n\n          if (i !== 0) {\n            this._createEdge(nodeList[i], Node);\n          }\n        }\n      }\n\n      console.log(\"\\u7F51\\u7EDC\\u6784\\u5EFA\\u5B8C\\u6210 \\u8282\\u70B9\\u6570: \".concat(this.nodes.size, \" \\u8FB9\\u6570\\u91CF: \").concat(this.edges.size));\n      return this;\n    } // 创建边连接\n\n  }, {\n    key: \"_createEdge\",\n    value: function _createEdge(nodeA, nodeB) {\n      var path = this._generateStraightPath(nodeA, nodeB);\n\n      var distance = this._distance(nodeA, nodeB); // 生成边键\n\n\n      var edgeKey = this._edgeKey(nodeA, nodeB);\n\n      var reverseEdgeKey = this._edgeKey(nodeB, nodeA); // 存储边数据\n\n\n      this.edges.set(edgeKey, {\n        path: path,\n        distance: distance\n      });\n      this.edges.set(reverseEdgeKey, {\n        path: _toConsumableArray(path).reverse(),\n        distance: distance\n      }); // 更新邻接表\n\n      this._updateAdjacencyList(nodeA, nodeB, distance);\n\n      this._updateAdjacencyList(nodeB, nodeA, distance);\n    } // Bresenham直线算法生成路径\n\n  }, {\n    key: \"_generateStraightPath\",\n    value: function _generateStraightPath(start, end) {\n      var x0 = Math.floor(start.x);\n      var y0 = Math.floor(start.y);\n      var x1 = Math.floor(end.x);\n      var y1 = Math.floor(end.y);\n      var dx = Math.abs(x1 - x0);\n      var dy = Math.abs(y1 - y0);\n      var sx = x0 < x1 ? 1 : -1;\n      var sy = y0 < y1 ? 1 : -1;\n      var err = dx - dy;\n      var path = [];\n\n      while (true) {\n        path.push({\n          x: x0,\n          y: y0\n        });\n        if (x0 === x1 && y0 === y1) break;\n        var e2 = 2 * err;\n\n        if (e2 > -dy) {\n          err -= dy;\n          x0 += sx;\n        }\n\n        if (e2 < dx) {\n          err += dx;\n          y0 += sy;\n        }\n      }\n\n      return path;\n    } // 更新邻接表\n\n  }, {\n    key: \"_updateAdjacencyList\",\n    value: function _updateAdjacencyList(fromNode, toNode, distance) {\n      var _this$adjacencyList$g3;\n\n      var fromKey = this._nodeKey(fromNode);\n\n      (_this$adjacencyList$g3 = this.adjacencyList.get(fromKey)) === null || _this$adjacencyList$g3 === void 0 ? void 0 : _this$adjacencyList$g3.push({\n        node: this._nodeKey(toNode),\n        distance: distance\n      });\n    } // 工具方法\n\n  }, {\n    key: \"clearNetwork\",\n    value: function clearNetwork() {\n      this.nodes.clear();\n      this.edges.clear();\n      this.adjacencyList.clear();\n    }\n  }, {\n    key: \"_nodeKey\",\n    value: function _nodeKey(point) {\n      return \"\".concat(point.x, \",\").concat(point.y);\n    }\n  }, {\n    key: \"_edgeKey\",\n    value: function _edgeKey(a, b) {\n      var _sort = [this._nodeKey(a), this._nodeKey(b)].sort(),\n          _sort2 = _slicedToArray(_sort, 2),\n          key1 = _sort2[0],\n          key2 = _sort2[1];\n\n      return \"\".concat(key1, \"-\").concat(key2);\n    }\n  }, {\n    key: \"_distance\",\n    value: function _distance(a, b) {\n      return Math.abs(a.x - b.x) + Math.abs(a.y - b.y);\n    } // 调试方法\n\n  }, {\n    key: \"printNetwork\",\n    value: function printNetwork() {\n      console.log('=== 节点列表 ===');\n      this.nodes.forEach(function (node, key) {\n        console.log(\"\\u8282\\u70B9 \".concat(key, \":\"), node);\n      });\n      console.log('=== 邻接表 ===');\n      this.adjacencyList.forEach(function (edges, key) {\n        console.log(\"\\u8282\\u70B9 \".concat(key, \" \\u8FDE\\u63A5\\u81F3:\"), edges);\n      });\n    }\n  }]);\n\n  return GraphNetwork;\n}();","map":{"version":3,"sources":["D:/Workspace/graduation_project/ElectronicMall/ElectronicMallVue/src/views/front/mall/canvasRenderer/pathfinder.js"],"names":["GraphNetwork","nodes","Map","edges","adjacencyList","a","b","x","y","isValid","forEach","_","key","split","get","some","n","node","console","error","point","_nodeKey","has","set","shopPoints","maxConnectionDistance","clearNetwork","shop","addNode","Math","floor","centerX","centerY","nodeList","Array","from","values","i","length","hasEdge","j","nodeA","nodeB","_distance","_createEdge","Node","log","size","path","_generateStraightPath","distance","edgeKey","_edgeKey","reverseEdgeKey","reverse","_updateAdjacencyList","start","end","x0","y0","x1","y1","dx","abs","dy","sx","sy","err","push","e2","fromNode","toNode","fromKey","clear","sort","key1","key2"],"mappings":"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","sourcesContent":["export class GraphNetwork {\r\n  constructor() {\r\n    this.nodes = new Map();    // 存储节点 {x, y}\r\n    this.edges = new Map();    // 存储边数据\r\n    this.adjacencyList = new Map(); // 邻接表\r\n  }\r\n  _nodeEquals(a, b) {\r\n    return a.x === b.x && a.y === b.y;\r\n  }\r\n\r\n  validate() {\r\n    let isValid = true;\r\n    \r\n    this.edges.forEach((_, key) => {\r\n      const [a, b] = key.split('-');\r\n      if (!this.adjacencyList.get(a)?.some(n => n.node === b)) {\r\n        console.error(`边 ${key} 不存在于邻接表`);\r\n        isValid = false;\r\n      }\r\n      if (!this.adjacencyList.get(b)?.some(n => n.node === a)) {\r\n        console.error(`反向边 ${key} 不存在于邻接表`);\r\n        isValid = false;\r\n      }\r\n    });\r\n\r\n    // 验证节点坐标有效性\r\n    this.nodes.forEach((node, key) => {\r\n      if (key !== `${node.x},${node.y}`) {\r\n        console.error(`节点坐标不匹配: ${key} vs ${node.x},${node.y}`);\r\n        isValid = false;\r\n      }\r\n    });\r\n\r\n    return isValid;\r\n  }\r\n\r\n\r\n  // 添加节点\r\n  addNode(point) {\r\n    const key = this._nodeKey(point);\r\n    if (!this.nodes.has(key)) {\r\n      this.nodes.set(key, { x: point.x, y: point.y });\r\n      this.adjacencyList.set(key, []);\r\n    }\r\n  }\r\n\r\n  // 构建网络（同步版本）\r\nbuildNetwork(shopPoints, maxConnectionDistance = 10) {\r\n  this.clearNetwork();\r\n  \r\n  // 添加所有节点\r\n  shopPoints.forEach(shop => {\r\n      this.addNode({\r\n          x: Math.floor(shop.centerX),\r\n          y: Math.floor(shop.centerY)\r\n      });\r\n  });\r\n\r\n  const nodeList = Array.from(this.nodes.values());\r\n  for (let i = 0; i < nodeList.length; i++) {\r\n      let hasEdge = false;\r\n      for (let j = i + 1; j < nodeList.length; j++) {\r\n          const nodeA = nodeList[i];\r\n          const nodeB = nodeList[j];\r\n          \r\n          if (this._distance(nodeA, nodeB) <= maxConnectionDistance) {\r\n              this._createEdge(nodeA, nodeB);\r\n              hasEdge = true;\r\n          }\r\n      }\r\n      // 如果当前点没有边，则强制与第一个点连接\r\n      if (!hasEdge && nodeList.length > 1) {\r\n          const Node = nodeList[40];\r\n          if (i!== 0) {\r\n              this._createEdge(nodeList[i], Node);\r\n          }\r\n      }\r\n  }\r\n  \r\n  console.log(`网络构建完成 节点数: ${this.nodes.size} 边数量: ${this.edges.size}`);\r\n  return this;\r\n}\r\n  // 创建边连接\r\n  _createEdge(nodeA, nodeB) {\r\n    const path = this._generateStraightPath(nodeA, nodeB);\r\n    const distance = this._distance(nodeA, nodeB);\r\n\r\n    // 生成边键\r\n    const edgeKey = this._edgeKey(nodeA, nodeB);\r\n    const reverseEdgeKey = this._edgeKey(nodeB, nodeA);\r\n\r\n    // 存储边数据\r\n    this.edges.set(edgeKey, { path, distance });\r\n    this.edges.set(reverseEdgeKey, { \r\n      path: [...path].reverse(), \r\n      distance \r\n    });\r\n\r\n    // 更新邻接表\r\n    this._updateAdjacencyList(nodeA, nodeB, distance);\r\n    this._updateAdjacencyList(nodeB, nodeA, distance);\r\n  }\r\n\r\n  // Bresenham直线算法生成路径\r\n  _generateStraightPath(start, end) {\r\n    let x0 = Math.floor(start.x);\r\n    let y0 = Math.floor(start.y);\r\n    const x1 = Math.floor(end.x);\r\n    const y1 = Math.floor(end.y);\r\n\r\n    const dx = Math.abs(x1 - x0);\r\n    const dy = Math.abs(y1 - y0);\r\n    const sx = x0 < x1 ? 1 : -1;\r\n    const sy = y0 < y1 ? 1 : -1;\r\n    let err = dx - dy;\r\n\r\n    const path = [];\r\n\r\n    while (true) {\r\n      path.push({ x: x0, y: y0 });\r\n\r\n      if (x0 === x1 && y0 === y1) break;\r\n\r\n      const e2 = 2 * err;\r\n      if (e2 > -dy) {\r\n        err -= dy;\r\n        x0 += sx;\r\n      }\r\n      if (e2 < dx) {\r\n        err += dx;\r\n        y0 += sy;\r\n      }\r\n    }\r\n\r\n    return path;\r\n  }\r\n\r\n  // 更新邻接表\r\n  _updateAdjacencyList(fromNode, toNode, distance) {\r\n    const fromKey = this._nodeKey(fromNode);\r\n    this.adjacencyList.get(fromKey)?.push({\r\n      node: this._nodeKey(toNode),\r\n      distance\r\n    });\r\n  }\r\n\r\n  // 工具方法\r\n  clearNetwork() {\r\n    this.nodes.clear();\r\n    this.edges.clear();\r\n    this.adjacencyList.clear();\r\n  }\r\n\r\n  _nodeKey(point) {\r\n    return `${point.x},${point.y}`;\r\n  }\r\n\r\n  _edgeKey(a, b) {\r\n    const [key1, key2] = [this._nodeKey(a), this._nodeKey(b)].sort();\r\n    return `${key1}-${key2}`;\r\n  }\r\n\r\n  _distance(a, b) {\r\n    return Math.abs(a.x - b.x) + Math.abs(a.y - b.y);\r\n}\r\n\r\n  // 调试方法\r\n  printNetwork() {\r\n    console.log('=== 节点列表 ===');\r\n    this.nodes.forEach((node, key) => {\r\n      console.log(`节点 ${key}:`, node);\r\n    });\r\n\r\n    console.log('=== 邻接表 ===');\r\n    this.adjacencyList.forEach((edges, key) => {\r\n      console.log(`节点 ${key} 连接至:`, edges);\r\n    });\r\n  }\r\n}"]},"metadata":{},"sourceType":"module"}