{"ast":null,"code":"import _classCallCheck from \"D:/Workspace/graduation_project/ElectronicMall/ElectronicMallVue/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"D:/Workspace/graduation_project/ElectronicMall/ElectronicMallVue/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/web.dom-collections.for-each.js\";\nimport \"core-js/modules/es.array.fill.js\";\nimport { drawShapes } from './shapes';\nimport { handleCollision } from './utils';\nimport { AStarPathfinder } from './pathfinder';\nexport var CanvasRenderer = /*#__PURE__*/function () {\n  function CanvasRenderer(vm, canvasId) {\n    _classCallCheck(this, CanvasRenderer);\n\n    this.vm = vm;\n    this.canvas = document.getElementById(canvasId);\n    this.ctx = this.canvas.getContext('2d');\n    this.animationFrame = null;\n    this.pathfinder = new AStarPathfinder(Math.floor(vm.canvasWidth / vm.gridSize), Math.floor(vm.canvasHeight / vm.gridSize));\n    this.currentPath = [];\n  }\n\n  _createClass(CanvasRenderer, [{\n    key: \"init\",\n    value: function init() {\n      this.drawGrid();\n      this.drawAllElements();\n    }\n  }, {\n    key: \"updatePath\",\n    value: function updatePath(start, end) {\n      this.pathfinder.setObstacles(this.vm.currentFloorObstacles);\n      this.currentPath = this.pathfinder.findPath(start, end) || [];\n    }\n  }, {\n    key: \"drawPath\",\n    value: function drawPath() {\n      if (this.currentPath.length === 0) return;\n      var ctx = this.ctx,\n          gridSize = this.vm.gridSize;\n      ctx.beginPath();\n      ctx.strokeStyle = '#ff0000';\n      ctx.lineWidth = 2;\n      this.currentPath.forEach(function (point, index) {\n        var x = (point.x + 0.5) * gridSize;\n        var y = (point.y + 0.5) * gridSize;\n\n        if (index === 0) {\n          ctx.moveTo(x, y);\n        } else {\n          ctx.lineTo(x, y);\n        }\n      });\n      ctx.stroke(); // 绘制路径点\n\n      ctx.fillStyle = '#00ff00';\n      this.currentPath.forEach(function (point) {\n        ctx.beginPath();\n        ctx.arc((point.x + 0.5) * gridSize, (point.y + 0.5) * gridSize, 3, 0, Math.PI * 2);\n        ctx.fill();\n      });\n    }\n  }, {\n    key: \"drawColoredGrid\",\n    value: function drawColoredGrid(x, y, color) {\n      var gridSize = this.vm.gridSize;\n      var startX = x * gridSize;\n      var startY = y * gridSize;\n      this.ctx.fillStyle = color;\n      this.ctx.fillRect(startX, startY, gridSize, gridSize);\n    }\n  }, {\n    key: \"drawGrid\",\n    value: function drawGrid() {\n      var ctx = this.ctx,\n          _this$vm = this.vm,\n          gridSize = _this$vm.gridSize,\n          canvasWidth = _this$vm.canvasWidth,\n          canvasHeight = _this$vm.canvasHeight;\n      ctx.strokeStyle = 'gray';\n      ctx.lineWidth = 1; // 绘制横向网格线\n\n      for (var y = 0; y <= canvasHeight; y += gridSize) {\n        ctx.beginPath();\n        ctx.moveTo(0, y);\n        ctx.lineTo(canvasWidth, y);\n        ctx.stroke();\n      } // 绘制纵向网格线\n\n\n      for (var x = 0; x <= canvasWidth; x += gridSize) {\n        ctx.beginPath();\n        ctx.moveTo(x, 0);\n        ctx.lineTo(x, canvasHeight);\n        ctx.stroke();\n      }\n    }\n  }, {\n    key: \"loadSecondFloor\",\n    value: function loadSecondFloor() {\n      this.currentFloorShops = this.secondFloorShops;\n      this.currentFloorObstacles = this.secondFloorObstacles;\n      this.blockX = 0;\n      this.blockY = 0;\n      this.currentFloor = '二楼';\n      drawAllElements();\n    }\n  }, {\n    key: \"loadFirstFloor\",\n    value: function loadFirstFloor() {\n      this.currentFloorShops = this.firstFloorShops;\n      this.currentFloorObstacles = this.firstFloorObstacles;\n      this.blockX = 0;\n      this.blockY = 0;\n      this.currentFloor = '一楼';\n      drawAllElements();\n    }\n  }, {\n    key: \"drawAllElements\",\n    value: function drawAllElements() {\n      var _this = this;\n\n      var ctx = this.ctx,\n          vm = this.vm;\n      ctx.clearRect(0, 0, vm.canvasWidth, vm.canvasHeight);\n      this.drawGrid();\n      this.drawShops();\n      this.drawObstacles();\n      this.drawPlayer();\n      this.drawPath();\n\n      if (vm.pathStart) {\n        this.drawColoredGrid(vm.pathStart.x, vm.pathStart.y, 'blue');\n      }\n\n      if (vm.pathEnd) {\n        this.drawColoredGrid(vm.pathEnd.x, vm.pathEnd.y, 'red');\n      }\n\n      this.animationFrame = requestAnimationFrame(function () {\n        return _this.drawAllElements();\n      });\n    }\n  }, {\n    key: \"drawShops\",\n    value: function drawShops() {\n      var _this2 = this;\n\n      var _this$vm2 = this.vm,\n          shops = _this$vm2.currentFloorShops,\n          gridSize = _this$vm2.gridSize;\n      shops.forEach(function (shop) {\n        return drawShapes[shop.shape](_this2.ctx, shop, gridSize);\n      });\n    }\n  }, {\n    key: \"drawObstacles\",\n    value: function drawObstacles() {\n      var _this3 = this;\n\n      var _this$vm3 = this.vm,\n          obstacles = _this$vm3.currentFloorObstacles,\n          gridSize = _this$vm3.gridSize,\n          treeImage = _this$vm3.treeImage;\n      obstacles.forEach(function (obs) {\n        if (treeImage.complete) {\n          _this3.ctx.drawImage(treeImage, obs.x * gridSize, obs.y * gridSize, gridSize, gridSize);\n        }\n      });\n    }\n  }, {\n    key: \"drawPlayer\",\n    value: function drawPlayer() {\n      var ctx = this.ctx,\n          _this$vm4 = this.vm,\n          blockX = _this$vm4.blockX,\n          blockY = _this$vm4.blockY,\n          gridSize = _this$vm4.gridSize;\n      ctx.fillStyle = 'red';\n      ctx.fillRect(blockX * gridSize, blockY * gridSize, gridSize, gridSize);\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      cancelAnimationFrame(this.animationFrame);\n    }\n  }]);\n\n  return CanvasRenderer;\n}();","map":{"version":3,"sources":["D:/Workspace/graduation_project/ElectronicMall/ElectronicMallVue/src/views/front/mall/canvasRenderer/index.js"],"names":["drawShapes","handleCollision","AStarPathfinder","CanvasRenderer","vm","canvasId","canvas","document","getElementById","ctx","getContext","animationFrame","pathfinder","Math","floor","canvasWidth","gridSize","canvasHeight","currentPath","drawGrid","drawAllElements","start","end","setObstacles","currentFloorObstacles","findPath","length","beginPath","strokeStyle","lineWidth","forEach","point","index","x","y","moveTo","lineTo","stroke","fillStyle","arc","PI","fill","color","startX","startY","fillRect","currentFloorShops","secondFloorShops","secondFloorObstacles","blockX","blockY","currentFloor","firstFloorShops","firstFloorObstacles","clearRect","drawShops","drawObstacles","drawPlayer","drawPath","pathStart","drawColoredGrid","pathEnd","requestAnimationFrame","shops","shop","shape","obstacles","treeImage","obs","complete","drawImage","cancelAnimationFrame"],"mappings":"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","sourcesContent":["import { drawShapes } from './shapes';\nimport { handleCollision } from './utils';\nimport { AStarPathfinder } from './pathfinder';\n\nexport class CanvasRenderer {\n  constructor(vm, canvasId) {\n    this.vm = vm;\n    this.canvas = document.getElementById(canvasId);\n    this.ctx = this.canvas.getContext('2d');\n    this.animationFrame = null;\n    this.pathfinder = new AStarPathfinder(\n      Math.floor(vm.canvasWidth / vm.gridSize),\n      Math.floor(vm.canvasHeight / vm.gridSize)\n    );\n    this.currentPath = [];\n  }\n\n  init() {\n    this.drawGrid();\n    this.drawAllElements(); \n  }\n  updatePath(start, end) {\n    this.pathfinder.setObstacles(this.vm.currentFloorObstacles);\n    this.currentPath = this.pathfinder.findPath(start, end) || [];\n  }\n\n  drawPath() {\n    if (this.currentPath.length === 0) return;\n\n    const { ctx, vm: { gridSize } } = this;\n    ctx.beginPath();\n    ctx.strokeStyle = '#ff0000';\n    ctx.lineWidth = 2;\n\n    this.currentPath.forEach((point, index) => {\n      const x = (point.x + 0.5) * gridSize;\n      const y = (point.y + 0.5) * gridSize;\n      \n      if (index === 0) {\n        ctx.moveTo(x, y);\n      } else {\n        ctx.lineTo(x, y);\n      }\n    });\n    ctx.stroke();\n    \n    // 绘制路径点\n    ctx.fillStyle = '#00ff00';\n    this.currentPath.forEach(point => {\n      ctx.beginPath();\n      ctx.arc(\n        (point.x + 0.5) * gridSize,\n        (point.y + 0.5) * gridSize,\n        3, 0, Math.PI * 2\n      );\n      ctx.fill();\n    });\n  }\n  drawColoredGrid(x, y, color) {\n    const gridSize = this.vm.gridSize;\n    const startX = x * gridSize;\n    const startY = y * gridSize;\n    this.ctx.fillStyle = color;\n    this.ctx.fillRect(startX, startY, gridSize, gridSize);\n  }\n\n  drawGrid() {\n    const { ctx, vm: { gridSize, canvasWidth, canvasHeight } } = this;\n    ctx.strokeStyle = 'gray';\n    ctx.lineWidth = 1;\n\n    // 绘制横向网格线\n    for (let y = 0; y <= canvasHeight; y += gridSize) {\n      ctx.beginPath();\n      ctx.moveTo(0, y);\n      ctx.lineTo(canvasWidth, y);\n      ctx.stroke();\n    }\n\n    // 绘制纵向网格线\n    for (let x = 0; x <= canvasWidth; x += gridSize) {\n      ctx.beginPath();\n      ctx.moveTo(x, 0);\n      ctx.lineTo(x, canvasHeight);\n      ctx.stroke();\n    }\n  }\n  loadSecondFloor (){\n    this.currentFloorShops = this.secondFloorShops;\n    this.currentFloorObstacles = this.secondFloorObstacles;\n    this.blockX = 0;\n    this.blockY = 0;\n    this.currentFloor = '二楼';\n    drawAllElements();\n  };\n\n  loadFirstFloor ()  {\n    this.currentFloorShops = this.firstFloorShops;\n    this.currentFloorObstacles = this.firstFloorObstacles;\n    this.blockX = 0;\n    this.blockY = 0;\n    this.currentFloor = '一楼';\n    drawAllElements();\n  };\n\n  drawAllElements() {\n    const { ctx, vm } = this;\n    ctx.clearRect(0, 0, vm.canvasWidth, vm.canvasHeight);\n    \n    this.drawGrid();\n    this.drawShops();\n    this.drawObstacles();\n    this.drawPlayer();\n    this.drawPath();\n\n    if (vm.pathStart) {\n      this.drawColoredGrid(vm.pathStart.x, vm.pathStart.y, 'blue');\n    }\n    if (vm.pathEnd) {\n      this.drawColoredGrid(vm.pathEnd.x, vm.pathEnd.y, 'red');\n    }\n    \n    this.animationFrame = requestAnimationFrame(() => this.drawAllElements());\n  }\n\n  drawShops() {\n    const { currentFloorShops: shops, gridSize } = this.vm;\n    shops.forEach(shop => drawShapes[shop.shape](this.ctx, shop, gridSize));\n  }\n\n  drawObstacles() {\n    const { currentFloorObstacles: obstacles, gridSize, treeImage } = this.vm;\n    obstacles.forEach(obs => {\n      if (treeImage.complete) {\n        this.ctx.drawImage(treeImage, obs.x * gridSize, obs.y * gridSize, gridSize, gridSize);\n      }\n    });\n  }\n\n  drawPlayer() {\n    const { ctx, vm: { blockX, blockY, gridSize } } = this;\n    ctx.fillStyle = 'red';\n    ctx.fillRect(blockX * gridSize, blockY * gridSize, gridSize, gridSize);\n  }\n\n  destroy() {\n    cancelAnimationFrame(this.animationFrame);\n  }\n}"]},"metadata":{},"sourceType":"module"}