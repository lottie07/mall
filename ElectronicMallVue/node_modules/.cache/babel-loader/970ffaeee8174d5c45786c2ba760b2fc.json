{"ast":null,"code":"import _typeof from \"D:/Workspace/graduation_project/ElectronicMall/ElectronicMallVue/node_modules/@babel/runtime/helpers/esm/typeof.js\";\nimport _objectSpread from \"D:/Workspace/graduation_project/ElectronicMall/ElectronicMallVue/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _classCallCheck from \"D:/Workspace/graduation_project/ElectronicMall/ElectronicMallVue/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"D:/Workspace/graduation_project/ElectronicMall/ElectronicMallVue/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.set.js\";\nimport \"core-js/modules/es.string.iterator.js\";\nimport \"core-js/modules/web.dom-collections.iterator.js\";\nimport \"core-js/modules/web.dom-collections.for-each.js\";\nimport \"core-js/modules/es.map.js\";\nimport \"core-js/modules/es.array.concat.js\";\nimport \"core-js/modules/es.array.splice.js\";\nexport var AStarPathfinder = /*#__PURE__*/function () {\n  function AStarPathfinder(gridWidth, gridHeight) {\n    _classCallCheck(this, AStarPathfinder);\n\n    this.grid = {\n      width: gridWidth,\n      height: gridHeight\n    };\n    this.obstacles = new Set();\n  } // 初始化障碍物\n\n\n  _createClass(AStarPathfinder, [{\n    key: \"setObstacles\",\n    value: function setObstacles(obstacles) {\n      var _this = this;\n\n      this.obstacles.clear();\n      obstacles.forEach(function (obs) {\n        _this.obstacles.add(_this._coordToKey(obs.x, obs.y));\n      });\n    } // A* 算法实现\n\n  }, {\n    key: \"findPath\",\n    value: function findPath(start, end) {\n      var _this2 = this;\n\n      var openSet = new PriorityQueue(function (a, b) {\n        return a.f < b.f;\n      });\n      var cameFrom = new Map();\n      var gScore = new Map();\n      var fScore = new Map();\n\n      var startKey = this._coordToKey(start.x, start.y);\n\n      var endKey = this._coordToKey(end.x, end.y);\n\n      gScore.set(startKey, 0);\n      fScore.set(startKey, this._heuristic(start, end));\n      openSet.enqueue(_objectSpread(_objectSpread({}, start), {}, {\n        f: fScore.get(startKey)\n      }));\n\n      var _loop = function _loop() {\n        var current = openSet.dequeue();\n\n        var currentKey = _this2._coordToKey(current.x, current.y);\n\n        if (currentKey === endKey) {\n          return {\n            v: _this2._reconstructPath(cameFrom, current)\n          };\n        }\n\n        _this2._getNeighbors(current).forEach(function (neighbor) {\n          var neighborKey = _this2._coordToKey(neighbor.x, neighbor.y);\n\n          var tentativeG = gScore.get(currentKey) + 1;\n\n          if (tentativeG < (gScore.get(neighborKey) || Infinity)) {\n            cameFrom.set(neighborKey, current);\n            gScore.set(neighborKey, tentativeG);\n            fScore.set(neighborKey, tentativeG + _this2._heuristic(neighbor, end));\n\n            if (!openSet.contains(neighbor, function (a, b) {\n              return a.x === b.x && a.y === b.y;\n            })) {\n              openSet.enqueue(_objectSpread(_objectSpread({}, neighbor), {}, {\n                f: fScore.get(neighborKey)\n              }));\n            }\n          }\n        });\n      };\n\n      while (!openSet.isEmpty()) {\n        var _ret = _loop();\n\n        if (_typeof(_ret) === \"object\") return _ret.v;\n      }\n\n      return null; // 无可用路径\n    } // 私有方法\n\n  }, {\n    key: \"_heuristic\",\n    value: function _heuristic(a, b) {\n      // 曼哈顿距离\n      return Math.abs(a.x - b.x) + Math.abs(a.y - b.y);\n    }\n  }, {\n    key: \"_getNeighbors\",\n    value: function _getNeighbors(node) {\n      var _this3 = this;\n\n      var neighbors = [];\n      var directions = [{\n        x: 1,\n        y: 0\n      }, // 右\n      {\n        x: -1,\n        y: 0\n      }, // 左\n      {\n        x: 0,\n        y: 1\n      }, // 下\n      {\n        x: 0,\n        y: -1\n      } // 上\n      ];\n      directions.forEach(function (dir) {\n        var x = node.x + dir.x;\n        var y = node.y + dir.y;\n\n        if (_this3._isWalkable(x, y)) {\n          neighbors.push({\n            x: x,\n            y: y\n          });\n        }\n      });\n      return neighbors;\n    }\n  }, {\n    key: \"_isWalkable\",\n    value: function _isWalkable(x, y) {\n      return x >= 0 && x < this.grid.width && y >= 0 && y < this.grid.height && !this.obstacles.has(this._coordToKey(x, y));\n    }\n  }, {\n    key: \"_coordToKey\",\n    value: function _coordToKey(x, y) {\n      return \"\".concat(x, \",\").concat(y);\n    }\n  }, {\n    key: \"_reconstructPath\",\n    value: function _reconstructPath(cameFrom, current) {\n      var path = [current];\n\n      while (cameFrom.has(this._coordToKey(current.x, current.y))) {\n        current = cameFrom.get(this._coordToKey(current.x, current.y));\n        path.unshift(current);\n      }\n\n      return path;\n    }\n  }]);\n\n  return AStarPathfinder;\n}(); // 优先队列实现\n\nvar PriorityQueue = /*#__PURE__*/function () {\n  function PriorityQueue(compare) {\n    _classCallCheck(this, PriorityQueue);\n\n    this.elements = [];\n    this.compare = compare;\n  }\n\n  _createClass(PriorityQueue, [{\n    key: \"enqueue\",\n    value: function enqueue(element) {\n      var added = false;\n\n      for (var i = 0; i < this.elements.length; i++) {\n        if (this.compare(element, this.elements[i])) {\n          this.elements.splice(i, 0, element);\n          added = true;\n          break;\n        }\n      }\n\n      if (!added) {\n        this.elements.push(element);\n      }\n    }\n  }, {\n    key: \"dequeue\",\n    value: function dequeue() {\n      return this.elements.shift();\n    }\n  }, {\n    key: \"isEmpty\",\n    value: function isEmpty() {\n      return this.elements.length === 0;\n    }\n  }, {\n    key: \"contains\",\n    value: function contains(element, equalFn) {\n      return this.elements.some(function (e) {\n        return equalFn(e, element);\n      });\n    }\n  }]);\n\n  return PriorityQueue;\n}();","map":{"version":3,"sources":["D:/Workspace/graduation_project/ElectronicMall/ElectronicMallVue/src/views/front/mall/canvasRenderer/pathfinder.js"],"names":["AStarPathfinder","gridWidth","gridHeight","grid","width","height","obstacles","Set","clear","forEach","obs","add","_coordToKey","x","y","start","end","openSet","PriorityQueue","a","b","f","cameFrom","Map","gScore","fScore","startKey","endKey","set","_heuristic","enqueue","get","current","dequeue","currentKey","_reconstructPath","_getNeighbors","neighbor","neighborKey","tentativeG","Infinity","contains","isEmpty","Math","abs","node","neighbors","directions","dir","_isWalkable","push","has","path","unshift","compare","elements","element","added","i","length","splice","shift","equalFn","some","e"],"mappings":"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","sourcesContent":["export class AStarPathfinder {\r\n    constructor(gridWidth, gridHeight) {\r\n      this.grid = {\r\n        width: gridWidth,\r\n        height: gridHeight\r\n      };\r\n      this.obstacles = new Set();\r\n    }\r\n  \r\n    // 初始化障碍物\r\n    setObstacles(obstacles) {\r\n      this.obstacles.clear();\r\n      obstacles.forEach(obs => {\r\n        this.obstacles.add(this._coordToKey(obs.x, obs.y));\r\n      });\r\n    }\r\n  \r\n    // A* 算法实现\r\n    findPath(start, end) {\r\n      const openSet = new PriorityQueue((a, b) => a.f < b.f);\r\n      const cameFrom = new Map();\r\n      const gScore = new Map();\r\n      const fScore = new Map();\r\n      \r\n      const startKey = this._coordToKey(start.x, start.y);\r\n      const endKey = this._coordToKey(end.x, end.y);\r\n  \r\n      gScore.set(startKey, 0);\r\n      fScore.set(startKey, this._heuristic(start, end));\r\n      openSet.enqueue({ ...start, f: fScore.get(startKey) });\r\n  \r\n      while (!openSet.isEmpty()) {\r\n        const current = openSet.dequeue();\r\n        const currentKey = this._coordToKey(current.x, current.y);\r\n  \r\n        if (currentKey === endKey) {\r\n          return this._reconstructPath(cameFrom, current);\r\n        }\r\n  \r\n        this._getNeighbors(current).forEach(neighbor => {\r\n          const neighborKey = this._coordToKey(neighbor.x, neighbor.y);\r\n          const tentativeG = gScore.get(currentKey) + 1;\r\n  \r\n          if (tentativeG < (gScore.get(neighborKey) || Infinity)) {\r\n            cameFrom.set(neighborKey, current);\r\n            gScore.set(neighborKey, tentativeG);\r\n            fScore.set(neighborKey, tentativeG + this._heuristic(neighbor, end));\r\n            \r\n            if (!openSet.contains(neighbor, (a, b) => \r\n              a.x === b.x && a.y === b.y)) {\r\n              openSet.enqueue({ \r\n                ...neighbor, \r\n                f: fScore.get(neighborKey) \r\n              });\r\n            }\r\n          }\r\n        });\r\n      }\r\n      return null; // 无可用路径\r\n    }\r\n  \r\n    // 私有方法\r\n    _heuristic(a, b) {\r\n      // 曼哈顿距离\r\n      return Math.abs(a.x - b.x) + Math.abs(a.y - b.y);\r\n    }\r\n  \r\n    _getNeighbors(node) {\r\n      const neighbors = [];\r\n      const directions = [\r\n        {x: 1, y: 0},  // 右\r\n        {x: -1, y: 0}, // 左\r\n        {x: 0, y: 1},  // 下\r\n        {x: 0, y: -1}  // 上\r\n      ];\r\n  \r\n      directions.forEach(dir => {\r\n        const x = node.x + dir.x;\r\n        const y = node.y + dir.y;\r\n        \r\n        if (this._isWalkable(x, y)) {\r\n          neighbors.push({ x, y });\r\n        }\r\n      });\r\n      return neighbors;\r\n    }\r\n  \r\n    _isWalkable(x, y) {\r\n      return x >= 0 && x < this.grid.width &&\r\n             y >= 0 && y < this.grid.height &&\r\n             !this.obstacles.has(this._coordToKey(x, y));\r\n    }\r\n  \r\n    _coordToKey(x, y) {\r\n      return `${x},${y}`;\r\n    }\r\n  \r\n    _reconstructPath(cameFrom, current) {\r\n      const path = [current];\r\n      while (cameFrom.has(this._coordToKey(current.x, current.y))) {\r\n        current = cameFrom.get(this._coordToKey(current.x, current.y));\r\n        path.unshift(current);\r\n      }\r\n      return path;\r\n    }\r\n  }\r\n  \r\n  // 优先队列实现\r\n  class PriorityQueue {\r\n    constructor(compare) {\r\n      this.elements = [];\r\n      this.compare = compare;\r\n    }\r\n  \r\n    enqueue(element) {\r\n      let added = false;\r\n      for (let i = 0; i < this.elements.length; i++) {\r\n        if (this.compare(element, this.elements[i])) {\r\n          this.elements.splice(i, 0, element);\r\n          added = true;\r\n          break;\r\n        }\r\n      }\r\n      if (!added) {\r\n        this.elements.push(element);\r\n      }\r\n    }\r\n  \r\n    dequeue() {\r\n      return this.elements.shift();\r\n    }\r\n  \r\n    isEmpty() {\r\n      return this.elements.length === 0;\r\n    }\r\n  \r\n    contains(element, equalFn) {\r\n      return this.elements.some(e => equalFn(e, element));\r\n    }\r\n  }"]},"metadata":{},"sourceType":"module"}