{"ast":null,"code":"import _slicedToArray from \"D:/Workspace/graduation_project/ElectronicMall/ElectronicMallVue/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _toConsumableArray from \"D:/Workspace/graduation_project/ElectronicMall/ElectronicMallVue/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _asyncToGenerator from \"D:/Workspace/graduation_project/ElectronicMall/ElectronicMallVue/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _classCallCheck from \"D:/Workspace/graduation_project/ElectronicMall/ElectronicMallVue/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"D:/Workspace/graduation_project/ElectronicMall/ElectronicMallVue/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport \"core-js/modules/es.array.map.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/web.dom-collections.for-each.js\";\nimport \"core-js/modules/es.array.concat.js\";\nimport \"core-js/modules/es.map.js\";\nimport \"core-js/modules/es.string.iterator.js\";\nimport \"core-js/modules/web.dom-collections.iterator.js\";\nimport \"core-js/modules/es.array.includes.js\";\nimport \"core-js/modules/es.array.fill.js\";\nimport \"core-js/modules/es.regexp.exec.js\";\nimport \"core-js/modules/es.string.split.js\";\nimport \"core-js/modules/es.number.constructor.js\";\nimport \"core-js/modules/es.array.splice.js\";\nimport \"regenerator-runtime/runtime.js\";\nimport { drawShapes } from './shapes';\nimport { handleCollision } from './utils';\nimport { GraphNetwork } from './pathfinder';\nimport { aStar } from './Astar';\nexport var CanvasRenderer = /*#__PURE__*/function () {\n  function CanvasRenderer(vm, canvasId) {\n    _classCallCheck(this, CanvasRenderer);\n\n    this.vm = vm;\n    this.canvas = document.getElementById(canvasId);\n    this.ctx = this.canvas.getContext('2d');\n    this.animationFrame = null;\n    this.currentPath = [];\n    this.network = new GraphNetwork();\n    this.gridSize = vm.gridSize;\n    this.gridWidth = Math.floor(vm.canvasWidth / this.gridSize);\n    this.gridHeight = Math.floor(vm.canvasHeight / this.gridSize);\n    this.pathfinder = new aStar(Math.floor(vm.canvasWidth / vm.gridSize), Math.floor(vm.canvasHeight / vm.gridSize));\n    vm.currentFloorWalls = [{\n      startX: 0,\n      startY: 0,\n      endX: 23,\n      endY: 0\n    }, {\n      startX: 23,\n      startY: 0,\n      endX: 24,\n      endY: 1\n    }, {\n      startX: 24,\n      startY: 1,\n      endX: 65,\n      endY: 1\n    }, {\n      startX: 65,\n      startY: 1,\n      endX: 65,\n      endY: 26\n    }, {\n      startX: 65,\n      startY: 26,\n      endX: 32,\n      endY: 26\n    }, {\n      startX: 32,\n      startY: 26,\n      endX: 32,\n      endY: 18\n    }, {\n      startX: 32,\n      startY: 18,\n      endX: 17,\n      endY: 18\n    }, {\n      startX: 17,\n      startY: 18,\n      endX: 14,\n      endY: 15\n    }, {\n      startX: 14,\n      startY: 15,\n      endX: 0,\n      endY: 15\n    }, {\n      startX: 0,\n      startY: 15,\n      endX: 0,\n      endY: 0\n    }];\n  }\n\n  _createClass(CanvasRenderer, [{\n    key: \"init\",\n    value: function () {\n      var _init = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {\n        return regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                this.drawGrid();\n                this.drawAllElements();\n                _context.next = 4;\n                return this.vm.fetchShops();\n\n              case 4:\n                this._buildShopNetwork();\n\n              case 5:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function init() {\n        return _init.apply(this, arguments);\n      }\n\n      return init;\n    }()\n  }, {\n    key: \"updateAstarPath\",\n    value: function updateAstarPath(start, end) {\n      this.pathfinder.setObstacles(this.vm.currentFloorObstacles);\n      this.currentPath = this.pathfinder.findPath(start, end) || [];\n    }\n  }, {\n    key: \"_buildShopNetwork\",\n    value: function _buildShopNetwork() {\n      console.log('this.vm.currentFloorShops:', this.vm.currentFloorShops);\n      var shopPoints = this.vm.currentFloorShops.map(function (shop) {\n        return {\n          centerX: Math.floor(shop.x + shop.width / 2),\n          centerY: Math.floor(shop.y + shop.height / 2)\n        };\n      });\n      this.network.buildNetwork(shopPoints, 8);\n    }\n  }, {\n    key: \"updatePath\",\n    value: function updatePath(start, end) {\n      this.currentPath = [];\n      var gridStart = {\n        x: Math.floor(start.x),\n        y: Math.floor(start.y)\n      };\n      var gridEnd = {\n        x: Math.floor(end.x),\n        y: Math.floor(end.y)\n      };\n\n      var startNode = this._findNearestNetworkNode(gridStart);\n\n      var endNode = this._findNearestNetworkNode(gridEnd);\n\n      if (!startNode || !endNode) {\n        this.currentPath = [];\n        return;\n      }\n\n      if (!this.network.validate()) {\n        console.error(\"网络结构验证失败\");\n        return;\n      }\n\n      var nodePath = this._findNodePath(startNode, endNode);\n\n      if (!nodePath || nodePath.length === 0) {\n        console.log(\"11\");\n        this.currentPath = [];\n        return;\n      } // 拼接实际路径\n\n\n      this.currentPath = this._resolveActualPath(nodePath);\n      console.log(\"currentPath\", this.currentPath);\n    }\n  }, {\n    key: \"_findNearestNetworkNode\",\n    value: function _findNearestNetworkNode(point) {\n      if (this.network.nodes.size === 0) return null;\n      var minDistance = Infinity;\n      var nearestNode = null;\n      this.network.nodes.forEach(function (node) {\n        var dx = node.x - point.x;\n        var dy = node.y - point.y;\n        var distance = dx * dx + dy * dy;\n\n        if (distance < minDistance) {\n          minDistance = distance;\n          nearestNode = node;\n        }\n      });\n      return nearestNode;\n    }\n  }, {\n    key: \"_findNodePath\",\n    value: function _findNodePath(startNode, endNode) {\n      var _this = this;\n\n      var startKey = this.network._nodeKey(startNode);\n\n      var endKey = this.network._nodeKey(endNode);\n\n      console.log(\"[\\u8DEF\\u5F84\\u67E5\\u627E] \\u8D77\\u59CB\\u8282\\u70B9: \".concat(startKey, \" -> \\u76EE\\u6807\\u8282\\u70B9: \").concat(endKey));\n      var distances = new Map();\n      var prev = new Map();\n      var pq = new PriorityQueue(function (a, b) {\n        return a.distance < b.distance;\n      }); // 初始化节点数据\n\n      this.network.nodes.forEach(function (_, key) {\n        distances.set(key, Infinity);\n        prev.set(key, null);\n      });\n      distances.set(startKey, 0);\n      pq.enqueue({\n        key: startKey,\n        distance: 0\n      });\n      var found = false;\n\n      var _loop = function _loop() {\n        var current = pq.dequeue();\n        console.log(\"[\\u5904\\u7406\\u8282\\u70B9] \".concat(current.key, \" (\\u5F53\\u524D\\u8DDD\\u79BB: \").concat(current.distance, \")\"));\n\n        if (current.key === endKey) {\n          found = true;\n          return \"break\";\n        } // 获取有效邻接节点\n\n\n        var neighbors = _this.network.adjacencyList.get(current.key) || [];\n        console.log(\"[\\u90BB\\u63A5\\u8282\\u70B9] \".concat(current.key, \" \\u7684\\u90BB\\u5C45:\"), neighbors.map(function (n) {\n          return n.node;\n        }));\n        neighbors.forEach(function (neighbor) {\n          var tentativeDistance = current.distance + neighbor.distance;\n          var currentDistance = distances.get(neighbor.node) || Infinity;\n          console.log(\"[\\u8DDD\\u79BB\\u8BA1\\u7B97] \".concat(current.key, \" -> \").concat(neighbor.node, \": \\n              \\u6682\\u5B9A \").concat(tentativeDistance, \" vs \\u5F53\\u524D \").concat(currentDistance));\n\n          if (tentativeDistance < currentDistance) {\n            console.log(\"[\\u66F4\\u65B0\\u8282\\u70B9] \".concat(neighbor.node, \" \\u65B0\\u8DDD\\u79BB: \").concat(tentativeDistance)); // 更新距离和前驱节点\n\n            distances.set(neighbor.node, tentativeDistance);\n            prev.set(neighbor.node, current.key); // 优化入队逻辑：先删除旧值再插入新值\n\n            pq.enqueue({\n              key: neighbor.node,\n              distance: tentativeDistance\n            });\n          }\n        });\n      };\n\n      while (!pq.isEmpty()) {\n        var _ret = _loop();\n\n        if (_ret === \"break\") break;\n      }\n\n      var path = [];\n      var currentKey = endKey;\n      var safetyCounter = 0; // 新增前驱节点有效性验证\n\n      if (!prev.has(endKey)) {\n        console.error(\"\\u7EC8\\u70B9 \".concat(endKey, \" \\u4E0D\\u53EF\\u8FBE\"));\n        return [];\n      }\n\n      while (currentKey && safetyCounter < 1000) {\n        safetyCounter++; // 验证节点存在性\n\n        if (!this.network.nodes.has(currentKey)) {\n          console.error(\"\\u65E0\\u6548\\u8282\\u70B9 \".concat(currentKey, \" \\u5B58\\u5728\\u4E8E\\u8DEF\\u5F84\\u4E2D\"));\n          return [];\n        }\n\n        path.unshift(this.network.nodes.get(currentKey));\n        currentKey = prev.get(currentKey);\n      } // 验证路径完整性\n\n\n      if (path.length === 0 || path[0].x !== startNode.x || path[0].y !== startNode.y || path[path.length - 1].x !== endNode.x || path[path.length - 1].y !== endNode.y) {\n        var _path$, _path$2;\n\n        console.error(\"路径不连贯，起始/终点不匹配\");\n        console.error(\"实际路径起点:\", (_path$ = path[0]) === null || _path$ === void 0 ? void 0 : _path$.x, (_path$2 = path[0]) === null || _path$2 === void 0 ? void 0 : _path$2.y);\n        console.error(\"预期路径起点:\", startNode.x, startNode.y);\n        return [];\n      } // 返回反转后的正确路径\n\n\n      return path.reverse();\n    } // 新增调试方法\n\n  }, {\n    key: \"_debugPrintPath\",\n    value: function _debugPrintPath(prev, startKey, endKey) {\n      console.groupCollapsed(\"[调试] 前驱节点映射\");\n      var current = endKey;\n      var path = [];\n\n      while (current) {\n        path.unshift(current);\n        current = prev.get(current);\n\n        if (path.includes(current)) {\n          console.log(\"发现循环:\", current);\n          break;\n        }\n      }\n\n      console.log(\"重构尝试路径:\", path);\n      console.groupEnd();\n    }\n  }, {\n    key: \"_resolveActualPath\",\n    value: function _resolveActualPath(nodePath) {\n      if (!nodePath || nodePath.length < 2) return [];\n      var fullPath = [];\n\n      try {\n        for (var i = 0; i < nodePath.length - 1; i++) {\n          var edgeKey = this.network._edgeKey(nodePath[i], nodePath[i + 1]);\n\n          var edge = this.network.edges.get(edgeKey);\n\n          if (edge && edge.path) {\n            fullPath.push.apply(fullPath, _toConsumableArray(edge.path));\n          }\n        }\n      } catch (e) {\n        console.error('路径解析错误:', e);\n        return [];\n      }\n\n      return fullPath;\n    } // 修改后的楼层切换方法\n\n  }, {\n    key: \"loadSecondFloor\",\n    value: function loadSecondFloor() {\n      this.vm.currentFloor = '二楼';\n      this.vm.blockX = 0;\n      this.vm.blockY = 0;\n      this.vm.pathEnd = null;\n      this.currentPath = [];\n\n      this._buildShopNetwork();\n\n      this.drawAllElements();\n    }\n  }, {\n    key: \"drawPath\",\n    value: function drawPath() {\n      if (this.currentPath.length === 0) return;\n      var ctx = this.ctx,\n          _this$vm = this.vm,\n          gridSize = _this$vm.gridSize,\n          pathStart = _this$vm.pathStart,\n          pathEnd = _this$vm.pathEnd;\n      ctx.beginPath();\n      ctx.strokeStyle = '#ff0000';\n      ctx.lineWidth = 2; // 绘制起点到临近节点的连线\n\n      if (pathStart) {\n        var startNode = this._findNearestNetworkNode(pathStart);\n\n        if (startNode) {\n          var startX = (pathStart.x + 0.5) * gridSize;\n          var startY = (pathStart.y + 0.5) * gridSize;\n          var nodeX = (startNode.x + 0.5) * gridSize;\n          var nodeY = (startNode.y + 0.5) * gridSize;\n          ctx.moveTo(startX, startY);\n          ctx.lineTo(nodeX, nodeY);\n        }\n      } // 绘制路径\n\n\n      this.currentPath.forEach(function (point, index) {\n        var x = (point.x + 0.5) * gridSize;\n        var y = (point.y + 0.5) * gridSize;\n        index === 0 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);\n      }); // 绘制终点到临近节点的连线\n\n      if (pathEnd) {\n        var endNode = this._findNearestNetworkNode(pathEnd);\n\n        if (endNode) {\n          var endX = (pathEnd.x + 0.5) * gridSize;\n          var endY = (pathEnd.y + 0.5) * gridSize;\n\n          var _nodeX = (endNode.x + 0.5) * gridSize;\n\n          var _nodeY = (endNode.y + 0.5) * gridSize;\n\n          ctx.moveTo(endX, endY);\n          ctx.lineTo(_nodeX, _nodeY);\n        }\n      }\n\n      ctx.stroke();\n    }\n  }, {\n    key: \"drawColoredGrid\",\n    value: function drawColoredGrid(x, y, color) {\n      var gridSize = this.vm.gridSize;\n      var startX = x * gridSize;\n      var startY = y * gridSize;\n      this.ctx.fillStyle = color;\n      this.ctx.fillRect(startX, startY, gridSize, gridSize);\n    }\n  }, {\n    key: \"drawGrid\",\n    value: function drawGrid() {\n      var ctx = this.ctx,\n          _this$vm2 = this.vm,\n          gridSize = _this$vm2.gridSize,\n          canvasWidth = _this$vm2.canvasWidth,\n          canvasHeight = _this$vm2.canvasHeight;\n      ctx.strokeStyle = 'gray';\n      ctx.lineWidth = 1; // 绘制横向网格线\n\n      for (var y = 0; y <= canvasHeight; y += gridSize) {\n        ctx.beginPath();\n        ctx.moveTo(0, y);\n        ctx.lineTo(canvasWidth, y);\n        ctx.stroke();\n      } // 绘制纵向网格线\n\n\n      for (var x = 0; x <= canvasWidth; x += gridSize) {\n        ctx.beginPath();\n        ctx.moveTo(x, 0);\n        ctx.lineTo(x, canvasHeight);\n        ctx.stroke();\n      }\n    }\n  }, {\n    key: \"loadFirstFloor\",\n    value: function loadFirstFloor() {\n      this.vm.currentFloor = '一楼';\n      this.vm.blockX = 0;\n      this.vm.blockY = 0;\n      this.vm.pathEnd = null;\n      this.currentPath = [];\n\n      this._buildShopNetwork();\n\n      this.drawAllElements();\n    }\n  }, {\n    key: \"drawAllElements\",\n    value: function drawAllElements() {\n      var _this2 = this;\n\n      var ctx = this.ctx,\n          vm = this.vm;\n      ctx.clearRect(0, 0, vm.canvasWidth, vm.canvasHeight);\n      this.drawGrid();\n      this.drawShops();\n      this.drawWalls();\n      this.drawObstacles();\n      this.drawPlayer();\n      this.drawPath(); //this.drawNetwork();\n\n      if (vm.pathStart) {\n        this.drawColoredGrid(vm.pathStart.x, vm.pathStart.y, 'blue');\n      }\n\n      if (vm.pathEnd) {\n        this.drawColoredGrid(vm.pathEnd.x, vm.pathEnd.y, 'red');\n      }\n\n      this.animationFrame = requestAnimationFrame(function () {\n        return _this2.drawAllElements();\n      });\n    }\n  }, {\n    key: \"drawShops\",\n    value: function drawShops() {\n      var _this$vm3 = this.vm,\n          shops = _this$vm3.currentFloorShops,\n          gridSize = _this$vm3.gridSize;\n      var ctx = this.ctx;\n      shops.forEach(function (shop) {\n        drawShapes[shop.shape](ctx, shop, gridSize);\n        ctx.save();\n        ctx.fillStyle = '#ffffff';\n        ctx.font = \"\".concat(Math.round(gridSize / 2), \"px Arial\");\n        ctx.textAlign = \"center\";\n        ctx.textBaseline = \"middle\";\n        var textX = (shop.x + shop.width / 2) * gridSize;\n        var textY = (shop.y + shop.height / 2) * gridSize;\n        ctx.strokeStyle = '#000000';\n        ctx.lineWidth = 2;\n        ctx.strokeText(shop.shopName, textX, textY);\n        ctx.fillText(shop.shopName, textX, textY);\n        ctx.restore();\n      });\n    }\n  }, {\n    key: \"drawObstacles\",\n    value: function drawObstacles() {\n      var _this3 = this;\n\n      var _this$vm4 = this.vm,\n          obstacles = _this$vm4.currentFloorObstacles,\n          gridSize = _this$vm4.gridSize,\n          treeImage = _this$vm4.treeImage;\n      obstacles.forEach(function (obs) {\n        if (treeImage.complete) {\n          _this3.ctx.drawImage(treeImage, obs.x * gridSize, obs.y * gridSize, gridSize, gridSize);\n        }\n      });\n    }\n  }, {\n    key: \"drawWalls\",\n    value: function drawWalls() {\n      var ctx = this.ctx,\n          _this$vm5 = this.vm,\n          gridSize = _this$vm5.gridSize,\n          currentFloorWalls = _this$vm5.currentFloorWalls;\n      ctx.fillStyle = '#666666';\n      ctx.strokeStyle = '#444444';\n      ctx.lineWidth = 10;\n      currentFloorWalls.forEach(function (wall) {\n        var startX = wall.startX * gridSize;\n        var startY = wall.startY * gridSize;\n        var endX = wall.endX * gridSize;\n        var endY = wall.endY * gridSize;\n        ctx.beginPath();\n        ctx.moveTo(startX, startY);\n        ctx.lineTo(endX, endY);\n        ctx.stroke();\n      });\n    }\n  }, {\n    key: \"drawNetwork\",\n    value: function drawNetwork() {\n      var ctx = this.ctx,\n          gridSize = this.vm.gridSize; // 绘制节点\n\n      ctx.fillStyle = 'blue';\n      this.network.nodes.forEach(function (node) {\n        ctx.beginPath();\n        ctx.arc((node.x + 0.5) * gridSize, (node.y + 0.5) * gridSize, 3, 0, Math.PI * 2);\n        ctx.fill();\n      }); // 绘制连接线和距离\n\n      ctx.strokeStyle = 'rgba(0,0,255,0.3)';\n      ctx.font = '10px Arial';\n      ctx.fillStyle = 'black';\n      this.network.edges.forEach(function (edge, key) {\n        var _key$split$map = key.split('-').map(function (k) {\n          var _k$split$map = k.split(',').map(Number),\n              _k$split$map2 = _slicedToArray(_k$split$map, 2),\n              x = _k$split$map2[0],\n              y = _k$split$map2[1];\n\n          return {\n            x: x,\n            y: y\n          };\n        }),\n            _key$split$map2 = _slicedToArray(_key$split$map, 2),\n            from = _key$split$map2[0],\n            to = _key$split$map2[1];\n\n        ctx.beginPath();\n        ctx.moveTo((from.x + 0.5) * gridSize, (from.y + 0.5) * gridSize);\n        ctx.lineTo((to.x + 0.5) * gridSize, (to.y + 0.5) * gridSize);\n        ctx.stroke(); // 计算边的中间位置\n\n        var midX = ((from.x + to.x) / 2 + 0.5) * gridSize;\n        var midY = ((from.y + to.y) / 2 + 0.5) * gridSize; // 绘制边的距离\n\n        ctx.fillText(edge.distance, midX, midY);\n      });\n    }\n  }, {\n    key: \"drawPlayer\",\n    value: function drawPlayer() {\n      var ctx = this.ctx,\n          _this$vm6 = this.vm,\n          blockX = _this$vm6.blockX,\n          blockY = _this$vm6.blockY,\n          gridSize = _this$vm6.gridSize;\n      ctx.fillStyle = 'red';\n      ctx.fillRect(blockX * gridSize, blockY * gridSize, gridSize, gridSize);\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      cancelAnimationFrame(this.animationFrame);\n    }\n  }]);\n\n  return CanvasRenderer;\n}();\n\nvar PriorityQueue = /*#__PURE__*/function () {\n  function PriorityQueue(compare) {\n    _classCallCheck(this, PriorityQueue);\n\n    this.elements = [];\n    this.compare = compare; // 使用Map记录节点索引提升性能\n\n    this.nodeIndices = new Map();\n  }\n\n  _createClass(PriorityQueue, [{\n    key: \"enqueue\",\n    value: function enqueue(element) {\n      // 移除旧条目\n      if (this.nodeIndices.has(element.key)) {\n        var index = this.nodeIndices.get(element.key);\n        this.elements.splice(index, 1);\n      } // 二分查找插入\n\n\n      var low = 0,\n          high = this.elements.length;\n\n      while (low < high) {\n        var mid = low + high >>> 1;\n\n        if (this.compare(element, this.elements[mid])) {\n          high = mid;\n        } else {\n          low = mid + 1;\n        }\n      }\n\n      this.elements.splice(low, 0, element); // 更新所有节点的索引（此处可以优化为只更新受影响的部分）\n\n      this._rebuildIndices();\n    }\n  }, {\n    key: \"dequeue\",\n    value: function dequeue() {\n      var element = this.elements.shift();\n\n      this._rebuildIndices();\n\n      return element;\n    }\n  }, {\n    key: \"_rebuildIndices\",\n    value: function _rebuildIndices() {\n      var _this4 = this;\n\n      this.nodeIndices.clear();\n      this.elements.forEach(function (el, index) {\n        _this4.nodeIndices.set(el.key, index);\n      });\n    }\n  }, {\n    key: \"isEmpty\",\n    value: function isEmpty() {\n      return this.elements.length === 0;\n    }\n  }]);\n\n  return PriorityQueue;\n}();","map":{"version":3,"sources":["D:/Workspace/graduation_project/ElectronicMall/ElectronicMallVue/src/views/front/mall/canvasRenderer/index.js"],"names":["drawShapes","handleCollision","GraphNetwork","aStar","CanvasRenderer","vm","canvasId","canvas","document","getElementById","ctx","getContext","animationFrame","currentPath","network","gridSize","gridWidth","Math","floor","canvasWidth","gridHeight","canvasHeight","pathfinder","currentFloorWalls","startX","startY","endX","endY","drawGrid","drawAllElements","fetchShops","_buildShopNetwork","start","end","setObstacles","currentFloorObstacles","findPath","console","log","currentFloorShops","shopPoints","map","shop","centerX","x","width","centerY","y","height","buildNetwork","gridStart","gridEnd","startNode","_findNearestNetworkNode","endNode","validate","error","nodePath","_findNodePath","length","_resolveActualPath","point","nodes","size","minDistance","Infinity","nearestNode","forEach","node","dx","dy","distance","startKey","_nodeKey","endKey","distances","Map","prev","pq","PriorityQueue","a","b","_","key","set","enqueue","found","current","dequeue","neighbors","adjacencyList","get","n","neighbor","tentativeDistance","currentDistance","isEmpty","path","currentKey","safetyCounter","has","unshift","reverse","groupCollapsed","includes","groupEnd","fullPath","i","edgeKey","_edgeKey","edge","edges","push","e","currentFloor","blockX","blockY","pathEnd","pathStart","beginPath","strokeStyle","lineWidth","nodeX","nodeY","moveTo","lineTo","index","stroke","color","fillStyle","fillRect","clearRect","drawShops","drawWalls","drawObstacles","drawPlayer","drawPath","drawColoredGrid","requestAnimationFrame","shops","shape","save","font","round","textAlign","textBaseline","textX","textY","strokeText","shopName","fillText","restore","obstacles","treeImage","obs","complete","drawImage","wall","arc","PI","fill","split","k","Number","from","to","midX","midY","cancelAnimationFrame","compare","elements","nodeIndices","element","splice","low","high","mid","_rebuildIndices","shift","clear","el"],"mappings":";;;;;;;;;;;;;;;;;;;AAAA,SAASA,UAAT,QAA2B,UAA3B;AACA,SAASC,eAAT,QAAgC,SAAhC;AACA,SAASC,YAAT,QAA6B,cAA7B;AACA,SAASC,KAAT,QAAsB,SAAtB;AAEA,WAAaC,cAAb;AACE,0BAAYC,EAAZ,EAAgBC,QAAhB,EAA0B;AAAA;;AACxB,SAAKD,EAAL,GAAUA,EAAV;AACA,SAAKE,MAAL,GAAcC,QAAQ,CAACC,cAAT,CAAwBH,QAAxB,CAAd;AACA,SAAKI,GAAL,GAAW,KAAKH,MAAL,CAAYI,UAAZ,CAAuB,IAAvB,CAAX;AACA,SAAKC,cAAL,GAAsB,IAAtB;AACA,SAAKC,WAAL,GAAmB,EAAnB;AACA,SAAKC,OAAL,GAAe,IAAIZ,YAAJ,EAAf;AAEA,SAAKa,QAAL,GAAgBV,EAAE,CAACU,QAAnB;AACA,SAAKC,SAAL,GAAiBC,IAAI,CAACC,KAAL,CAAWb,EAAE,CAACc,WAAH,GAAiB,KAAKJ,QAAjC,CAAjB;AACA,SAAKK,UAAL,GAAkBH,IAAI,CAACC,KAAL,CAAWb,EAAE,CAACgB,YAAH,GAAkB,KAAKN,QAAlC,CAAlB;AAEA,SAAKO,UAAL,GAAkB,IAAInB,KAAJ,CAChBc,IAAI,CAACC,KAAL,CAAWb,EAAE,CAACc,WAAH,GAAiBd,EAAE,CAACU,QAA/B,CADgB,EAEhBE,IAAI,CAACC,KAAL,CAAWb,EAAE,CAACgB,YAAH,GAAkBhB,EAAE,CAACU,QAAhC,CAFgB,CAAlB;AAIAV,IAAAA,EAAE,CAACkB,iBAAH,GAAuB,CACrB;AAAEC,MAAAA,MAAM,EAAE,CAAV;AAAaC,MAAAA,MAAM,EAAE,CAArB;AAAwBC,MAAAA,IAAI,EAAE,EAA9B;AAAkCC,MAAAA,IAAI,EAAE;AAAxC,KADqB,EAErB;AAAEH,MAAAA,MAAM,EAAE,EAAV;AAAcC,MAAAA,MAAM,EAAE,CAAtB;AAAyBC,MAAAA,IAAI,EAAE,EAA/B;AAAmCC,MAAAA,IAAI,EAAE;AAAzC,KAFqB,EAGrB;AAAEH,MAAAA,MAAM,EAAE,EAAV;AAAcC,MAAAA,MAAM,EAAE,CAAtB;AAAyBC,MAAAA,IAAI,EAAE,EAA/B;AAAmCC,MAAAA,IAAI,EAAE;AAAzC,KAHqB,EAIrB;AAAEH,MAAAA,MAAM,EAAE,EAAV;AAAcC,MAAAA,MAAM,EAAE,CAAtB;AAAyBC,MAAAA,IAAI,EAAE,EAA/B;AAAmCC,MAAAA,IAAI,EAAE;AAAzC,KAJqB,EAKrB;AAAEH,MAAAA,MAAM,EAAE,EAAV;AAAcC,MAAAA,MAAM,EAAE,EAAtB;AAA0BC,MAAAA,IAAI,EAAE,EAAhC;AAAoCC,MAAAA,IAAI,EAAE;AAA1C,KALqB,EAMrB;AAAEH,MAAAA,MAAM,EAAE,EAAV;AAAcC,MAAAA,MAAM,EAAE,EAAtB;AAA0BC,MAAAA,IAAI,EAAE,EAAhC;AAAoCC,MAAAA,IAAI,EAAE;AAA1C,KANqB,EAOrB;AAAEH,MAAAA,MAAM,EAAE,EAAV;AAAcC,MAAAA,MAAM,EAAE,EAAtB;AAA0BC,MAAAA,IAAI,EAAE,EAAhC;AAAoCC,MAAAA,IAAI,EAAE;AAA1C,KAPqB,EAQrB;AAAEH,MAAAA,MAAM,EAAE,EAAV;AAAcC,MAAAA,MAAM,EAAE,EAAtB;AAA0BC,MAAAA,IAAI,EAAE,EAAhC;AAAoCC,MAAAA,IAAI,EAAE;AAA1C,KARqB,EASrB;AAAEH,MAAAA,MAAM,EAAE,EAAV;AAAcC,MAAAA,MAAM,EAAE,EAAtB;AAA0BC,MAAAA,IAAI,EAAE,CAAhC;AAAmCC,MAAAA,IAAI,EAAE;AAAzC,KATqB,EAUrB;AAAEH,MAAAA,MAAM,EAAE,CAAV;AAAaC,MAAAA,MAAM,EAAE,EAArB;AAAyBC,MAAAA,IAAI,EAAE,CAA/B;AAAkCC,MAAAA,IAAI,EAAE;AAAxC,KAVqB,CAAvB;AAYD;;AA7BH;AAAA;AAAA;AAAA,0EA+BE;AAAA;AAAA;AAAA;AAAA;AACE,qBAAKC,QAAL;AACA,qBAAKC,eAAL;AAFF;AAAA,uBAGQ,KAAKxB,EAAL,CAAQyB,UAAR,EAHR;;AAAA;AAIE,qBAAKC,iBAAL;;AAJF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,OA/BF;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA,WAqCE,yBAAgBC,KAAhB,EAAuBC,GAAvB,EAA4B;AAC1B,WAAKX,UAAL,CAAgBY,YAAhB,CAA6B,KAAK7B,EAAL,CAAQ8B,qBAArC;AACA,WAAKtB,WAAL,GAAmB,KAAKS,UAAL,CAAgBc,QAAhB,CAAyBJ,KAAzB,EAAgCC,GAAhC,KAAwC,EAA3D;AACD;AAxCH;AAAA;AAAA,WAyCE,6BAAoB;AAClBI,MAAAA,OAAO,CAACC,GAAR,CAAY,4BAAZ,EAA0C,KAAKjC,EAAL,CAAQkC,iBAAlD;AACA,UAAMC,UAAU,GAAG,KAAKnC,EAAL,CAAQkC,iBAAR,CAA0BE,GAA1B,CAA8B,UAAAC,IAAI;AAAA,eAAK;AACxDC,UAAAA,OAAO,EAAE1B,IAAI,CAACC,KAAL,CAAWwB,IAAI,CAACE,CAAL,GAASF,IAAI,CAACG,KAAL,GAAW,CAA/B,CAD+C;AAExDC,UAAAA,OAAO,EAAE7B,IAAI,CAACC,KAAL,CAAWwB,IAAI,CAACK,CAAL,GAASL,IAAI,CAACM,MAAL,GAAY,CAAhC;AAF+C,SAAL;AAAA,OAAlC,CAAnB;AAKA,WAAKlC,OAAL,CAAamC,YAAb,CAA0BT,UAA1B,EAAsC,CAAtC;AACD;AAjDH;AAAA;AAAA,WAkDE,oBAAWR,KAAX,EAAkBC,GAAlB,EAAuB;AACrB,WAAKpB,WAAL,GAAmB,EAAnB;AAEA,UAAMqC,SAAS,GAAG;AAChBN,QAAAA,CAAC,EAAE3B,IAAI,CAACC,KAAL,CAAWc,KAAK,CAACY,CAAjB,CADa;AAEhBG,QAAAA,CAAC,EAAE9B,IAAI,CAACC,KAAL,CAAWc,KAAK,CAACe,CAAjB;AAFa,OAAlB;AAIA,UAAMI,OAAO,GAAG;AACdP,QAAAA,CAAC,EAAE3B,IAAI,CAACC,KAAL,CAAWe,GAAG,CAACW,CAAf,CADW;AAEdG,QAAAA,CAAC,EAAE9B,IAAI,CAACC,KAAL,CAAWe,GAAG,CAACc,CAAf;AAFW,OAAhB;;AAKA,UAAMK,SAAS,GAAG,KAAKC,uBAAL,CAA6BH,SAA7B,CAAlB;;AACA,UAAMI,OAAO,GAAG,KAAKD,uBAAL,CAA6BF,OAA7B,CAAhB;;AAEA,UAAI,CAACC,SAAD,IAAc,CAACE,OAAnB,EAA4B;AAC1B,aAAKzC,WAAL,GAAmB,EAAnB;AACA;AACD;;AACD,UAAI,CAAC,KAAKC,OAAL,CAAayC,QAAb,EAAL,EAA8B;AAC5BlB,QAAAA,OAAO,CAACmB,KAAR,CAAc,UAAd;AACA;AACD;;AAED,UAAMC,QAAQ,GAAG,KAAKC,aAAL,CAAmBN,SAAnB,EAA8BE,OAA9B,CAAjB;;AACA,UAAI,CAACG,QAAD,IAAaA,QAAQ,CAACE,MAAT,KAAoB,CAArC,EAAwC;AACtCtB,QAAAA,OAAO,CAACC,GAAR,CAAY,IAAZ;AACA,aAAKzB,WAAL,GAAmB,EAAnB;AACA;AACD,OA7BoB,CA+BrB;;;AACA,WAAKA,WAAL,GAAmB,KAAK+C,kBAAL,CAAwBH,QAAxB,CAAnB;AACApB,MAAAA,OAAO,CAACC,GAAR,CAAY,aAAZ,EAA0B,KAAKzB,WAA/B;AACD;AApFH;AAAA;AAAA,WAuFE,iCAAwBgD,KAAxB,EAA+B;AAC7B,UAAI,KAAK/C,OAAL,CAAagD,KAAb,CAAmBC,IAAnB,KAA4B,CAAhC,EAAmC,OAAO,IAAP;AAEnC,UAAIC,WAAW,GAAGC,QAAlB;AACA,UAAIC,WAAW,GAAG,IAAlB;AAEA,WAAKpD,OAAL,CAAagD,KAAb,CAAmBK,OAAnB,CAA2B,UAAAC,IAAI,EAAI;AACjC,YAAMC,EAAE,GAAGD,IAAI,CAACxB,CAAL,GAASiB,KAAK,CAACjB,CAA1B;AACA,YAAM0B,EAAE,GAAGF,IAAI,CAACrB,CAAL,GAASc,KAAK,CAACd,CAA1B;AACA,YAAMwB,QAAQ,GAAGF,EAAE,GAACA,EAAH,GAAQC,EAAE,GAACA,EAA5B;;AAEA,YAAIC,QAAQ,GAAGP,WAAf,EAA4B;AAC1BA,UAAAA,WAAW,GAAGO,QAAd;AACAL,UAAAA,WAAW,GAAGE,IAAd;AACD;AACF,OATD;AAWA,aAAOF,WAAP;AACD;AAzGH;AAAA;AAAA,WA2GA,uBAAcd,SAAd,EAAyBE,OAAzB,EAAkC;AAAA;;AAChC,UAAMkB,QAAQ,GAAG,KAAK1D,OAAL,CAAa2D,QAAb,CAAsBrB,SAAtB,CAAjB;;AACA,UAAMsB,MAAM,GAAG,KAAK5D,OAAL,CAAa2D,QAAb,CAAsBnB,OAAtB,CAAf;;AACAjB,MAAAA,OAAO,CAACC,GAAR,gEAA4BkC,QAA5B,2CAAiDE,MAAjD;AAEA,UAAMC,SAAS,GAAG,IAAIC,GAAJ,EAAlB;AACA,UAAMC,IAAI,GAAG,IAAID,GAAJ,EAAb;AACA,UAAME,EAAE,GAAG,IAAIC,aAAJ,CAAkB,UAACC,CAAD,EAAIC,CAAJ;AAAA,eAAUD,CAAC,CAACT,QAAF,GAAaU,CAAC,CAACV,QAAzB;AAAA,OAAlB,CAAX,CAPgC,CAShC;;AACA,WAAKzD,OAAL,CAAagD,KAAb,CAAmBK,OAAnB,CAA2B,UAACe,CAAD,EAAIC,GAAJ,EAAY;AACnCR,QAAAA,SAAS,CAACS,GAAV,CAAcD,GAAd,EAAmBlB,QAAnB;AACAY,QAAAA,IAAI,CAACO,GAAL,CAASD,GAAT,EAAc,IAAd;AACH,OAHD;AAKAR,MAAAA,SAAS,CAACS,GAAV,CAAcZ,QAAd,EAAwB,CAAxB;AACAM,MAAAA,EAAE,CAACO,OAAH,CAAW;AAAEF,QAAAA,GAAG,EAAEX,QAAP;AAAiBD,QAAAA,QAAQ,EAAE;AAA3B,OAAX;AAEA,UAAIe,KAAK,GAAG,KAAZ;;AAlBgC;AAoB5B,YAAMC,OAAO,GAAGT,EAAE,CAACU,OAAH,EAAhB;AACAnD,QAAAA,OAAO,CAACC,GAAR,sCAAsBiD,OAAO,CAACJ,GAA9B,yCAA4CI,OAAO,CAAChB,QAApD;;AACA,YAAIgB,OAAO,CAACJ,GAAR,KAAgBT,MAApB,EAA4B;AACxBY,UAAAA,KAAK,GAAG,IAAR;AACA;AACH,SAzB2B,CA0B5B;;;AACA,YAAMG,SAAS,GAAG,KAAI,CAAC3E,OAAL,CAAa4E,aAAb,CAA2BC,GAA3B,CAA+BJ,OAAO,CAACJ,GAAvC,KAA+C,EAAjE;AACA9C,QAAAA,OAAO,CAACC,GAAR,sCAAsBiD,OAAO,CAACJ,GAA9B,2BAA0CM,SAAS,CAAChD,GAAV,CAAc,UAAAmD,CAAC;AAAA,iBAAIA,CAAC,CAACxB,IAAN;AAAA,SAAf,CAA1C;AAEAqB,QAAAA,SAAS,CAACtB,OAAV,CAAkB,UAAA0B,QAAQ,EAAI;AAC1B,cAAMC,iBAAiB,GAAGP,OAAO,CAAChB,QAAR,GAAmBsB,QAAQ,CAACtB,QAAtD;AACA,cAAMwB,eAAe,GAAGpB,SAAS,CAACgB,GAAV,CAAcE,QAAQ,CAACzB,IAAvB,KAAgCH,QAAxD;AAEA5B,UAAAA,OAAO,CAACC,GAAR,sCAAsBiD,OAAO,CAACJ,GAA9B,iBAAwCU,QAAQ,CAACzB,IAAjD,4CACS0B,iBADT,8BACoCC,eADpC;;AAGA,cAAID,iBAAiB,GAAGC,eAAxB,EAAyC;AACrC1D,YAAAA,OAAO,CAACC,GAAR,sCAAsBuD,QAAQ,CAACzB,IAA/B,kCAA4C0B,iBAA5C,GADqC,CAGrC;;AACAnB,YAAAA,SAAS,CAACS,GAAV,CAAcS,QAAQ,CAACzB,IAAvB,EAA6B0B,iBAA7B;AACAjB,YAAAA,IAAI,CAACO,GAAL,CAASS,QAAQ,CAACzB,IAAlB,EAAwBmB,OAAO,CAACJ,GAAhC,EALqC,CAOrC;;AACAL,YAAAA,EAAE,CAACO,OAAH,CAAW;AACPF,cAAAA,GAAG,EAAEU,QAAQ,CAACzB,IADP;AAEPG,cAAAA,QAAQ,EAAEuB;AAFH,aAAX;AAIH;AACJ,SApBD;AA9B4B;;AAmBhC,aAAO,CAAChB,EAAE,CAACkB,OAAH,EAAR,EAAsB;AAAA;;AAAA,8BAKd;AA2BP;;AAGD,UAAMC,IAAI,GAAG,EAAb;AACE,UAAIC,UAAU,GAAGxB,MAAjB;AACA,UAAIyB,aAAa,GAAG,CAApB,CAxD8B,CA0D9B;;AACA,UAAI,CAACtB,IAAI,CAACuB,GAAL,CAAS1B,MAAT,CAAL,EAAuB;AACnBrC,QAAAA,OAAO,CAACmB,KAAR,wBAAoBkB,MAApB;AACA,eAAO,EAAP;AACH;;AAED,aAAOwB,UAAU,IAAIC,aAAa,GAAG,IAArC,EAA2C;AACvCA,QAAAA,aAAa,GAD0B,CAGvC;;AACA,YAAI,CAAC,KAAKrF,OAAL,CAAagD,KAAb,CAAmBsC,GAAnB,CAAuBF,UAAvB,CAAL,EAAyC;AACrC7D,UAAAA,OAAO,CAACmB,KAAR,oCAAsB0C,UAAtB;AACA,iBAAO,EAAP;AACH;;AAEDD,QAAAA,IAAI,CAACI,OAAL,CAAa,KAAKvF,OAAL,CAAagD,KAAb,CAAmB6B,GAAnB,CAAuBO,UAAvB,CAAb;AACAA,QAAAA,UAAU,GAAGrB,IAAI,CAACc,GAAL,CAASO,UAAT,CAAb;AACH,OA3E6B,CA6E9B;;;AACA,UAAID,IAAI,CAACtC,MAAL,KAAgB,CAAhB,IACAsC,IAAI,CAAC,CAAD,CAAJ,CAAQrD,CAAR,KAAcQ,SAAS,CAACR,CADxB,IAC6BqD,IAAI,CAAC,CAAD,CAAJ,CAAQlD,CAAR,KAAcK,SAAS,CAACL,CADrD,IAEAkD,IAAI,CAACA,IAAI,CAACtC,MAAL,GAAc,CAAf,CAAJ,CAAsBf,CAAtB,KAA4BU,OAAO,CAACV,CAFpC,IAEyCqD,IAAI,CAACA,IAAI,CAACtC,MAAL,GAAc,CAAf,CAAJ,CAAsBZ,CAAtB,KAA4BO,OAAO,CAACP,CAFjF,EAGE;AAAA;;AACEV,QAAAA,OAAO,CAACmB,KAAR,CAAc,gBAAd;AACAnB,QAAAA,OAAO,CAACmB,KAAR,CAAc,SAAd,YAAyByC,IAAI,CAAC,CAAD,CAA7B,2CAAyB,OAASrD,CAAlC,aAAqCqD,IAAI,CAAC,CAAD,CAAzC,4CAAqC,QAASlD,CAA9C;AACAV,QAAAA,OAAO,CAACmB,KAAR,CAAc,SAAd,EAAyBJ,SAAS,CAACR,CAAnC,EAAsCQ,SAAS,CAACL,CAAhD;AACA,eAAO,EAAP;AACH,OAtF6B,CAwF9B;;;AACA,aAAOkD,IAAI,CAACK,OAAL,EAAP;AACH,KArMD,CAuMA;;AAvMA;AAAA;AAAA,WAwMA,yBAAgBzB,IAAhB,EAAsBL,QAAtB,EAAgCE,MAAhC,EAAwC;AACtCrC,MAAAA,OAAO,CAACkE,cAAR,CAAuB,aAAvB;AACA,UAAIhB,OAAO,GAAGb,MAAd;AACA,UAAMuB,IAAI,GAAG,EAAb;;AACA,aAAOV,OAAP,EAAgB;AACZU,QAAAA,IAAI,CAACI,OAAL,CAAad,OAAb;AACAA,QAAAA,OAAO,GAAGV,IAAI,CAACc,GAAL,CAASJ,OAAT,CAAV;;AACA,YAAIU,IAAI,CAACO,QAAL,CAAcjB,OAAd,CAAJ,EAA4B;AACxBlD,UAAAA,OAAO,CAACC,GAAR,CAAY,OAAZ,EAAqBiD,OAArB;AACA;AACH;AACJ;;AACDlD,MAAAA,OAAO,CAACC,GAAR,CAAY,SAAZ,EAAuB2D,IAAvB;AACA5D,MAAAA,OAAO,CAACoE,QAAR;AACD;AAtND;AAAA;AAAA,WAyNE,4BAAmBhD,QAAnB,EAA6B;AAC3B,UAAI,CAACA,QAAD,IAAaA,QAAQ,CAACE,MAAT,GAAkB,CAAnC,EAAsC,OAAO,EAAP;AAEtC,UAAM+C,QAAQ,GAAG,EAAjB;;AACA,UAAI;AACF,aAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGlD,QAAQ,CAACE,MAAT,GAAkB,CAAtC,EAAyCgD,CAAC,EAA1C,EAA8C;AAC5C,cAAMC,OAAO,GAAG,KAAK9F,OAAL,CAAa+F,QAAb,CAAsBpD,QAAQ,CAACkD,CAAD,CAA9B,EAAmClD,QAAQ,CAACkD,CAAC,GAAC,CAAH,CAA3C,CAAhB;;AACA,cAAMG,IAAI,GAAG,KAAKhG,OAAL,CAAaiG,KAAb,CAAmBpB,GAAnB,CAAuBiB,OAAvB,CAAb;;AAEA,cAAIE,IAAI,IAAIA,IAAI,CAACb,IAAjB,EAAuB;AACrBS,YAAAA,QAAQ,CAACM,IAAT,OAAAN,QAAQ,qBAASI,IAAI,CAACb,IAAd,EAAR;AACD;AACF;AACF,OATD,CASE,OAAOgB,CAAP,EAAU;AACV5E,QAAAA,OAAO,CAACmB,KAAR,CAAc,SAAd,EAAyByD,CAAzB;AACA,eAAO,EAAP;AACD;;AACD,aAAOP,QAAP;AACD,KA3OH,CA6OE;;AA7OF;AAAA;AAAA,WA8OE,2BAAkB;AAChB,WAAKrG,EAAL,CAAQ6G,YAAR,GAAuB,IAAvB;AACA,WAAK7G,EAAL,CAAQ8G,MAAR,GAAiB,CAAjB;AACA,WAAK9G,EAAL,CAAQ+G,MAAR,GAAiB,CAAjB;AACA,WAAK/G,EAAL,CAAQgH,OAAR,GAAkB,IAAlB;AACA,WAAKxG,WAAL,GAAmB,EAAnB;;AACA,WAAKkB,iBAAL;;AACA,WAAKF,eAAL;AACD;AAtPH;AAAA;AAAA,WAyPE,oBAAW;AACT,UAAI,KAAKhB,WAAL,CAAiB8C,MAAjB,KAA4B,CAAhC,EAAmC;AAEnC,UAAQjD,GAAR,GAAsD,IAAtD,CAAQA,GAAR;AAAA,qBAAsD,IAAtD,CAAaL,EAAb;AAAA,UAAmBU,QAAnB,YAAmBA,QAAnB;AAAA,UAA6BuG,SAA7B,YAA6BA,SAA7B;AAAA,UAAwCD,OAAxC,YAAwCA,OAAxC;AACA3G,MAAAA,GAAG,CAAC6G,SAAJ;AACA7G,MAAAA,GAAG,CAAC8G,WAAJ,GAAkB,SAAlB;AACA9G,MAAAA,GAAG,CAAC+G,SAAJ,GAAgB,CAAhB,CANS,CAQT;;AACA,UAAIH,SAAJ,EAAe;AACb,YAAMlE,SAAS,GAAG,KAAKC,uBAAL,CAA6BiE,SAA7B,CAAlB;;AACA,YAAIlE,SAAJ,EAAe;AACb,cAAM5B,MAAM,GAAG,CAAC8F,SAAS,CAAC1E,CAAV,GAAc,GAAf,IAAsB7B,QAArC;AACA,cAAMU,MAAM,GAAG,CAAC6F,SAAS,CAACvE,CAAV,GAAc,GAAf,IAAsBhC,QAArC;AACA,cAAM2G,KAAK,GAAG,CAACtE,SAAS,CAACR,CAAV,GAAc,GAAf,IAAsB7B,QAApC;AACA,cAAM4G,KAAK,GAAG,CAACvE,SAAS,CAACL,CAAV,GAAc,GAAf,IAAsBhC,QAApC;AACAL,UAAAA,GAAG,CAACkH,MAAJ,CAAWpG,MAAX,EAAmBC,MAAnB;AACAf,UAAAA,GAAG,CAACmH,MAAJ,CAAWH,KAAX,EAAkBC,KAAlB;AACD;AACF,OAnBQ,CAqBT;;;AACA,WAAK9G,WAAL,CAAiBsD,OAAjB,CAAyB,UAACN,KAAD,EAAQiE,KAAR,EAAkB;AACzC,YAAMlF,CAAC,GAAG,CAACiB,KAAK,CAACjB,CAAN,GAAU,GAAX,IAAkB7B,QAA5B;AACA,YAAMgC,CAAC,GAAG,CAACc,KAAK,CAACd,CAAN,GAAU,GAAX,IAAkBhC,QAA5B;AACA+G,QAAAA,KAAK,KAAK,CAAV,GAAcpH,GAAG,CAACkH,MAAJ,CAAWhF,CAAX,EAAcG,CAAd,CAAd,GAAiCrC,GAAG,CAACmH,MAAJ,CAAWjF,CAAX,EAAcG,CAAd,CAAjC;AACD,OAJD,EAtBS,CA4BT;;AACA,UAAIsE,OAAJ,EAAa;AACX,YAAM/D,OAAO,GAAG,KAAKD,uBAAL,CAA6BgE,OAA7B,CAAhB;;AACA,YAAI/D,OAAJ,EAAa;AACX,cAAM5B,IAAI,GAAG,CAAC2F,OAAO,CAACzE,CAAR,GAAY,GAAb,IAAoB7B,QAAjC;AACA,cAAMY,IAAI,GAAG,CAAC0F,OAAO,CAACtE,CAAR,GAAY,GAAb,IAAoBhC,QAAjC;;AACA,cAAM2G,MAAK,GAAG,CAACpE,OAAO,CAACV,CAAR,GAAY,GAAb,IAAoB7B,QAAlC;;AACA,cAAM4G,MAAK,GAAG,CAACrE,OAAO,CAACP,CAAR,GAAY,GAAb,IAAoBhC,QAAlC;;AACAL,UAAAA,GAAG,CAACkH,MAAJ,CAAWlG,IAAX,EAAiBC,IAAjB;AACAjB,UAAAA,GAAG,CAACmH,MAAJ,CAAWH,MAAX,EAAkBC,MAAlB;AACD;AACF;;AAEDjH,MAAAA,GAAG,CAACqH,MAAJ;AACD;AAnSH;AAAA;AAAA,WAqSE,yBAAgBnF,CAAhB,EAAmBG,CAAnB,EAAsBiF,KAAtB,EAA6B;AAC3B,UAAMjH,QAAQ,GAAG,KAAKV,EAAL,CAAQU,QAAzB;AACA,UAAMS,MAAM,GAAGoB,CAAC,GAAG7B,QAAnB;AACA,UAAMU,MAAM,GAAGsB,CAAC,GAAGhC,QAAnB;AACA,WAAKL,GAAL,CAASuH,SAAT,GAAqBD,KAArB;AACA,WAAKtH,GAAL,CAASwH,QAAT,CAAkB1G,MAAlB,EAA0BC,MAA1B,EAAkCV,QAAlC,EAA4CA,QAA5C;AACD;AA3SH;AAAA;AAAA,WA6SE,oBAAW;AACT,UAAQL,GAAR,GAA6D,IAA7D,CAAQA,GAAR;AAAA,sBAA6D,IAA7D,CAAaL,EAAb;AAAA,UAAmBU,QAAnB,aAAmBA,QAAnB;AAAA,UAA6BI,WAA7B,aAA6BA,WAA7B;AAAA,UAA0CE,YAA1C,aAA0CA,YAA1C;AACAX,MAAAA,GAAG,CAAC8G,WAAJ,GAAkB,MAAlB;AACA9G,MAAAA,GAAG,CAAC+G,SAAJ,GAAgB,CAAhB,CAHS,CAKT;;AACA,WAAK,IAAI1E,CAAC,GAAG,CAAb,EAAgBA,CAAC,IAAI1B,YAArB,EAAmC0B,CAAC,IAAIhC,QAAxC,EAAkD;AAChDL,QAAAA,GAAG,CAAC6G,SAAJ;AACA7G,QAAAA,GAAG,CAACkH,MAAJ,CAAW,CAAX,EAAc7E,CAAd;AACArC,QAAAA,GAAG,CAACmH,MAAJ,CAAW1G,WAAX,EAAwB4B,CAAxB;AACArC,QAAAA,GAAG,CAACqH,MAAJ;AACD,OAXQ,CAaT;;;AACA,WAAK,IAAInF,CAAC,GAAG,CAAb,EAAgBA,CAAC,IAAIzB,WAArB,EAAkCyB,CAAC,IAAI7B,QAAvC,EAAiD;AAC/CL,QAAAA,GAAG,CAAC6G,SAAJ;AACA7G,QAAAA,GAAG,CAACkH,MAAJ,CAAWhF,CAAX,EAAc,CAAd;AACAlC,QAAAA,GAAG,CAACmH,MAAJ,CAAWjF,CAAX,EAAcvB,YAAd;AACAX,QAAAA,GAAG,CAACqH,MAAJ;AACD;AACF;AAjUH;AAAA;AAAA,WAqUE,0BAAkB;AAChB,WAAK1H,EAAL,CAAQ6G,YAAR,GAAuB,IAAvB;AACA,WAAK7G,EAAL,CAAQ8G,MAAR,GAAiB,CAAjB;AACA,WAAK9G,EAAL,CAAQ+G,MAAR,GAAiB,CAAjB;AACA,WAAK/G,EAAL,CAAQgH,OAAR,GAAkB,IAAlB;AACA,WAAKxG,WAAL,GAAmB,EAAnB;;AACA,WAAKkB,iBAAL;;AACA,WAAKF,eAAL;AACD;AA7UH;AAAA;AAAA,WA+UE,2BAAkB;AAAA;;AAChB,UAAQnB,GAAR,GAAoB,IAApB,CAAQA,GAAR;AAAA,UAAaL,EAAb,GAAoB,IAApB,CAAaA,EAAb;AACAK,MAAAA,GAAG,CAACyH,SAAJ,CAAc,CAAd,EAAiB,CAAjB,EAAoB9H,EAAE,CAACc,WAAvB,EAAoCd,EAAE,CAACgB,YAAvC;AAEA,WAAKO,QAAL;AACA,WAAKwG,SAAL;AACA,WAAKC,SAAL;AACA,WAAKC,aAAL;AACA,WAAKC,UAAL;AACA,WAAKC,QAAL,GATgB,CAUhB;;AAEA,UAAInI,EAAE,CAACiH,SAAP,EAAkB;AAChB,aAAKmB,eAAL,CAAqBpI,EAAE,CAACiH,SAAH,CAAa1E,CAAlC,EAAqCvC,EAAE,CAACiH,SAAH,CAAavE,CAAlD,EAAqD,MAArD;AACD;;AACD,UAAI1C,EAAE,CAACgH,OAAP,EAAgB;AACd,aAAKoB,eAAL,CAAqBpI,EAAE,CAACgH,OAAH,CAAWzE,CAAhC,EAAmCvC,EAAE,CAACgH,OAAH,CAAWtE,CAA9C,EAAiD,KAAjD;AACD;;AAED,WAAKnC,cAAL,GAAsB8H,qBAAqB,CAAC;AAAA,eAAM,MAAI,CAAC7G,eAAL,EAAN;AAAA,OAAD,CAA3C;AACD;AAnWH;AAAA;AAAA,WAqWE,qBAAY;AACV,sBAA+C,KAAKxB,EAApD;AAAA,UAA2BsI,KAA3B,aAAQpG,iBAAR;AAAA,UAAkCxB,QAAlC,aAAkCA,QAAlC;AACA,UAAQL,GAAR,GAAgB,IAAhB,CAAQA,GAAR;AAEAiI,MAAAA,KAAK,CAACxE,OAAN,CAAc,UAAAzB,IAAI,EAAI;AACpB1C,QAAAA,UAAU,CAAC0C,IAAI,CAACkG,KAAN,CAAV,CAAuBlI,GAAvB,EAA4BgC,IAA5B,EAAkC3B,QAAlC;AAEAL,QAAAA,GAAG,CAACmI,IAAJ;AACAnI,QAAAA,GAAG,CAACuH,SAAJ,GAAgB,SAAhB;AACAvH,QAAAA,GAAG,CAACoI,IAAJ,aAAc7H,IAAI,CAAC8H,KAAL,CAAWhI,QAAQ,GAAC,CAApB,CAAd;AACAL,QAAAA,GAAG,CAACsI,SAAJ,GAAgB,QAAhB;AACAtI,QAAAA,GAAG,CAACuI,YAAJ,GAAmB,QAAnB;AAEA,YAAMC,KAAK,GAAG,CAACxG,IAAI,CAACE,CAAL,GAASF,IAAI,CAACG,KAAL,GAAW,CAArB,IAA0B9B,QAAxC;AACA,YAAMoI,KAAK,GAAG,CAACzG,IAAI,CAACK,CAAL,GAASL,IAAI,CAACM,MAAL,GAAY,CAAtB,IAA2BjC,QAAzC;AAEAL,QAAAA,GAAG,CAAC8G,WAAJ,GAAkB,SAAlB;AACA9G,QAAAA,GAAG,CAAC+G,SAAJ,GAAgB,CAAhB;AACA/G,QAAAA,GAAG,CAAC0I,UAAJ,CAAe1G,IAAI,CAAC2G,QAApB,EAA8BH,KAA9B,EAAqCC,KAArC;AAEAzI,QAAAA,GAAG,CAAC4I,QAAJ,CAAa5G,IAAI,CAAC2G,QAAlB,EAA4BH,KAA5B,EAAmCC,KAAnC;AACAzI,QAAAA,GAAG,CAAC6I,OAAJ;AACD,OAlBD;AAmBD;AA5XH;AAAA;AAAA,WA8XE,yBAAgB;AAAA;;AACd,sBAAkE,KAAKlJ,EAAvE;AAAA,UAA+BmJ,SAA/B,aAAQrH,qBAAR;AAAA,UAA0CpB,QAA1C,aAA0CA,QAA1C;AAAA,UAAoD0I,SAApD,aAAoDA,SAApD;AACAD,MAAAA,SAAS,CAACrF,OAAV,CAAkB,UAAAuF,GAAG,EAAI;AACvB,YAAID,SAAS,CAACE,QAAd,EAAwB;AACtB,UAAA,MAAI,CAACjJ,GAAL,CAASkJ,SAAT,CAAmBH,SAAnB,EAA8BC,GAAG,CAAC9G,CAAJ,GAAQ7B,QAAtC,EAAgD2I,GAAG,CAAC3G,CAAJ,GAAQhC,QAAxD,EAAkEA,QAAlE,EAA4EA,QAA5E;AACD;AACF,OAJD;AAKD;AArYH;AAAA;AAAA,WAsYE,qBAAY;AACV,UAAQL,GAAR,GAAqD,IAArD,CAAQA,GAAR;AAAA,sBAAqD,IAArD,CAAaL,EAAb;AAAA,UAAmBU,QAAnB,aAAmBA,QAAnB;AAAA,UAA6BQ,iBAA7B,aAA6BA,iBAA7B;AACAb,MAAAA,GAAG,CAACuH,SAAJ,GAAgB,SAAhB;AAEAvH,MAAAA,GAAG,CAAC8G,WAAJ,GAAkB,SAAlB;AACA9G,MAAAA,GAAG,CAAC+G,SAAJ,GAAgB,EAAhB;AAEAlG,MAAAA,iBAAiB,CAAC4C,OAAlB,CAA0B,UAAA0F,IAAI,EAAI;AAChC,YAAMrI,MAAM,GAAGqI,IAAI,CAACrI,MAAL,GAAcT,QAA7B;AACA,YAAMU,MAAM,GAAGoI,IAAI,CAACpI,MAAL,GAAcV,QAA7B;AACA,YAAMW,IAAI,GAAGmI,IAAI,CAACnI,IAAL,GAAYX,QAAzB;AACA,YAAMY,IAAI,GAAGkI,IAAI,CAAClI,IAAL,GAAYZ,QAAzB;AAEAL,QAAAA,GAAG,CAAC6G,SAAJ;AACA7G,QAAAA,GAAG,CAACkH,MAAJ,CAAWpG,MAAX,EAAmBC,MAAnB;AACAf,QAAAA,GAAG,CAACmH,MAAJ,CAAWnG,IAAX,EAAiBC,IAAjB;AACAjB,QAAAA,GAAG,CAACqH,MAAJ;AACD,OAVD;AAWD;AAxZH;AAAA;AAAA,WA0ZE,uBAAc;AACZ,UAAQrH,GAAR,GAAkC,IAAlC,CAAQA,GAAR;AAAA,UAAmBK,QAAnB,GAAkC,IAAlC,CAAaV,EAAb,CAAmBU,QAAnB,CADY,CAGZ;;AACAL,MAAAA,GAAG,CAACuH,SAAJ,GAAgB,MAAhB;AACA,WAAKnH,OAAL,CAAagD,KAAb,CAAmBK,OAAnB,CAA2B,UAAAC,IAAI,EAAI;AAC/B1D,QAAAA,GAAG,CAAC6G,SAAJ;AACA7G,QAAAA,GAAG,CAACoJ,GAAJ,CACI,CAAC1F,IAAI,CAACxB,CAAL,GAAS,GAAV,IAAiB7B,QADrB,EAEI,CAACqD,IAAI,CAACrB,CAAL,GAAS,GAAV,IAAiBhC,QAFrB,EAGI,CAHJ,EAGO,CAHP,EAGUE,IAAI,CAAC8I,EAAL,GAAU,CAHpB;AAKArJ,QAAAA,GAAG,CAACsJ,IAAJ;AACH,OARD,EALY,CAeZ;;AACAtJ,MAAAA,GAAG,CAAC8G,WAAJ,GAAkB,mBAAlB;AACA9G,MAAAA,GAAG,CAACoI,IAAJ,GAAW,YAAX;AACApI,MAAAA,GAAG,CAACuH,SAAJ,GAAgB,OAAhB;AACA,WAAKnH,OAAL,CAAaiG,KAAb,CAAmB5C,OAAnB,CAA2B,UAAC2C,IAAD,EAAO3B,GAAP,EAAe;AACtC,6BAAmBA,GAAG,CAAC8E,KAAJ,CAAU,GAAV,EAAexH,GAAf,CAAmB,UAAAyH,CAAC,EAAI;AACvC,6BAAeA,CAAC,CAACD,KAAF,CAAQ,GAAR,EAAaxH,GAAb,CAAiB0H,MAAjB,CAAf;AAAA;AAAA,cAAOvH,CAAP;AAAA,cAAUG,CAAV;;AACA,iBAAO;AAAEH,YAAAA,CAAC,EAADA,CAAF;AAAKG,YAAAA,CAAC,EAADA;AAAL,WAAP;AACH,SAHkB,CAAnB;AAAA;AAAA,YAAOqH,IAAP;AAAA,YAAaC,EAAb;;AAKA3J,QAAAA,GAAG,CAAC6G,SAAJ;AACA7G,QAAAA,GAAG,CAACkH,MAAJ,CAAW,CAACwC,IAAI,CAACxH,CAAL,GAAS,GAAV,IAAiB7B,QAA5B,EAAsC,CAACqJ,IAAI,CAACrH,CAAL,GAAS,GAAV,IAAiBhC,QAAvD;AACAL,QAAAA,GAAG,CAACmH,MAAJ,CAAW,CAACwC,EAAE,CAACzH,CAAH,GAAO,GAAR,IAAe7B,QAA1B,EAAoC,CAACsJ,EAAE,CAACtH,CAAH,GAAO,GAAR,IAAehC,QAAnD;AACAL,QAAAA,GAAG,CAACqH,MAAJ,GATsC,CAWtC;;AACA,YAAMuC,IAAI,GAAG,CAAC,CAACF,IAAI,CAACxH,CAAL,GAASyH,EAAE,CAACzH,CAAb,IAAkB,CAAlB,GAAsB,GAAvB,IAA8B7B,QAA3C;AACA,YAAMwJ,IAAI,GAAG,CAAC,CAACH,IAAI,CAACrH,CAAL,GAASsH,EAAE,CAACtH,CAAb,IAAkB,CAAlB,GAAsB,GAAvB,IAA8BhC,QAA3C,CAbsC,CAetC;;AACAL,QAAAA,GAAG,CAAC4I,QAAJ,CAAaxC,IAAI,CAACvC,QAAlB,EAA4B+F,IAA5B,EAAkCC,IAAlC;AACH,OAjBD;AAkBH;AA/bD;AAAA;AAAA,WAicE,sBAAa;AACX,UAAQ7J,GAAR,GAAkD,IAAlD,CAAQA,GAAR;AAAA,sBAAkD,IAAlD,CAAaL,EAAb;AAAA,UAAmB8G,MAAnB,aAAmBA,MAAnB;AAAA,UAA2BC,MAA3B,aAA2BA,MAA3B;AAAA,UAAmCrG,QAAnC,aAAmCA,QAAnC;AACAL,MAAAA,GAAG,CAACuH,SAAJ,GAAgB,KAAhB;AACAvH,MAAAA,GAAG,CAACwH,QAAJ,CAAaf,MAAM,GAAGpG,QAAtB,EAAgCqG,MAAM,GAAGrG,QAAzC,EAAmDA,QAAnD,EAA6DA,QAA7D;AACD;AArcH;AAAA;AAAA,WAucE,mBAAU;AACRyJ,MAAAA,oBAAoB,CAAC,KAAK5J,cAAN,CAApB;AACD;AAzcH;;AAAA;AAAA;;IA2cMmE,a;AACJ,yBAAY0F,OAAZ,EAAqB;AAAA;;AACnB,SAAKC,QAAL,GAAgB,EAAhB;AACA,SAAKD,OAAL,GAAeA,OAAf,CAFmB,CAGnB;;AACA,SAAKE,WAAL,GAAmB,IAAI/F,GAAJ,EAAnB;AACD;;;;WAED,iBAAQgG,OAAR,EAAiB;AACf;AACA,UAAI,KAAKD,WAAL,CAAiBvE,GAAjB,CAAqBwE,OAAO,CAACzF,GAA7B,CAAJ,EAAuC;AACrC,YAAM2C,KAAK,GAAG,KAAK6C,WAAL,CAAiBhF,GAAjB,CAAqBiF,OAAO,CAACzF,GAA7B,CAAd;AACA,aAAKuF,QAAL,CAAcG,MAAd,CAAqB/C,KAArB,EAA4B,CAA5B;AACD,OALc,CAOf;;;AACA,UAAIgD,GAAG,GAAG,CAAV;AAAA,UAAaC,IAAI,GAAG,KAAKL,QAAL,CAAc/G,MAAlC;;AACA,aAAOmH,GAAG,GAAGC,IAAb,EAAmB;AACjB,YAAMC,GAAG,GAAIF,GAAG,GAAGC,IAAP,KAAiB,CAA7B;;AACA,YAAI,KAAKN,OAAL,CAAaG,OAAb,EAAsB,KAAKF,QAAL,CAAcM,GAAd,CAAtB,CAAJ,EAA+C;AAC7CD,UAAAA,IAAI,GAAGC,GAAP;AACD,SAFD,MAEO;AACLF,UAAAA,GAAG,GAAGE,GAAG,GAAG,CAAZ;AACD;AACF;;AAED,WAAKN,QAAL,CAAcG,MAAd,CAAqBC,GAArB,EAA0B,CAA1B,EAA6BF,OAA7B,EAlBe,CAmBf;;AACA,WAAKK,eAAL;AACD;;;WAED,mBAAU;AACR,UAAML,OAAO,GAAG,KAAKF,QAAL,CAAcQ,KAAd,EAAhB;;AACA,WAAKD,eAAL;;AACA,aAAOL,OAAP;AACD;;;WAED,2BAAkB;AAAA;;AAChB,WAAKD,WAAL,CAAiBQ,KAAjB;AACA,WAAKT,QAAL,CAAcvG,OAAd,CAAsB,UAACiH,EAAD,EAAKtD,KAAL,EAAe;AACnC,QAAA,MAAI,CAAC6C,WAAL,CAAiBvF,GAAjB,CAAqBgG,EAAE,CAACjG,GAAxB,EAA6B2C,KAA7B;AACD,OAFD;AAGD;;;WAED,mBAAU;AACR,aAAO,KAAK4C,QAAL,CAAc/G,MAAd,KAAyB,CAAhC;AACD","sourcesContent":["import { drawShapes } from './shapes';\r\nimport { handleCollision } from './utils';\r\nimport { GraphNetwork } from './pathfinder';\r\nimport { aStar } from './Astar';\r\n\r\nexport class CanvasRenderer {\r\n  constructor(vm, canvasId) {\r\n    this.vm = vm;\r\n    this.canvas = document.getElementById(canvasId);\r\n    this.ctx = this.canvas.getContext('2d');\r\n    this.animationFrame = null;\r\n    this.currentPath = [];\r\n    this.network = new GraphNetwork(); \r\n\r\n    this.gridSize = vm.gridSize;\r\n    this.gridWidth = Math.floor(vm.canvasWidth / this.gridSize);\r\n    this.gridHeight = Math.floor(vm.canvasHeight / this.gridSize);\r\n\r\n    this.pathfinder = new aStar(\r\n      Math.floor(vm.canvasWidth / vm.gridSize),\r\n      Math.floor(vm.canvasHeight / vm.gridSize)\r\n    );\r\n    vm.currentFloorWalls = [\r\n      { startX: 0, startY: 0, endX: 23, endY: 0 },\r\n      { startX: 23, startY: 0, endX: 24, endY: 1 },\r\n      { startX: 24, startY: 1, endX: 65, endY: 1 },      \r\n      { startX: 65, startY: 1, endX: 65, endY: 26 },  \r\n      { startX: 65, startY: 26, endX: 32, endY: 26 },\r\n      { startX: 32, startY: 26, endX: 32, endY: 18 },\r\n      { startX: 32, startY: 18, endX: 17, endY: 18 },      \r\n      { startX: 17, startY: 18, endX: 14, endY: 15 },         \r\n      { startX: 14, startY: 15, endX: 0, endY: 15 },        \r\n      { startX: 0, startY: 15, endX: 0, endY: 0 },\r\n    ];\r\n  }\r\n\r\n  async init() {    \r\n    this.drawGrid();\r\n    this.drawAllElements(); \r\n    await this.vm.fetchShops();\r\n    this._buildShopNetwork();\r\n  }\r\n  updateAstarPath(start, end) {\r\n    this.pathfinder.setObstacles(this.vm.currentFloorObstacles);\r\n    this.currentPath = this.pathfinder.findPath(start, end) || [];\r\n  }\r\n  _buildShopNetwork() {\r\n    console.log('this.vm.currentFloorShops:', this.vm.currentFloorShops);\r\n    const shopPoints = this.vm.currentFloorShops.map(shop => ({\r\n      centerX: Math.floor(shop.x + shop.width/2),\r\n      centerY: Math.floor(shop.y + shop.height/2)\r\n    }));\r\n    \r\n    this.network.buildNetwork(shopPoints, 8); \r\n  }\r\n  updatePath(start, end) {  \r\n    this.currentPath = [];\r\n\r\n    const gridStart = {\r\n      x: Math.floor(start.x),\r\n      y: Math.floor(start.y)\r\n    };\r\n    const gridEnd = {\r\n      x: Math.floor(end.x),\r\n      y: Math.floor(end.y)\r\n    };\r\n\r\n    const startNode = this._findNearestNetworkNode(gridStart);\r\n    const endNode = this._findNearestNetworkNode(gridEnd);\r\n    \r\n    if (!startNode || !endNode) {\r\n      this.currentPath = [];\r\n      return;\r\n    }\r\n    if (!this.network.validate()) {\r\n      console.error(\"网络结构验证失败\");\r\n      return;\r\n    }\r\n\r\n    const nodePath = this._findNodePath(startNode, endNode);\r\n    if (!nodePath || nodePath.length === 0) {\r\n      console.log(\"11\")      \r\n      this.currentPath = [];\r\n      return;\r\n    }\r\n\r\n    // 拼接实际路径\r\n    this.currentPath = this._resolveActualPath(nodePath);\r\n    console.log(\"currentPath\",this.currentPath)\r\n  }\r\n  \r\n\r\n  _findNearestNetworkNode(point) {\r\n    if (this.network.nodes.size === 0) return null;\r\n\r\n    let minDistance = Infinity;\r\n    let nearestNode = null;\r\n\r\n    this.network.nodes.forEach(node => {\r\n      const dx = node.x - point.x;\r\n      const dy = node.y - point.y;\r\n      const distance = dx*dx + dy*dy;\r\n      \r\n      if (distance < minDistance) {\r\n        minDistance = distance;\r\n        nearestNode = node;\r\n      }\r\n    });\r\n\r\n    return nearestNode;\r\n  }\r\n  \r\n_findNodePath(startNode, endNode) {\r\n  const startKey = this.network._nodeKey(startNode);\r\n  const endKey = this.network._nodeKey(endNode);\r\n  console.log(`[路径查找] 起始节点: ${startKey} -> 目标节点: ${endKey}`);\r\n\r\n  const distances = new Map();\r\n  const prev = new Map();\r\n  const pq = new PriorityQueue((a, b) => a.distance < b.distance);\r\n\r\n  // 初始化节点数据\r\n  this.network.nodes.forEach((_, key) => {\r\n      distances.set(key, Infinity);\r\n      prev.set(key, null);\r\n  });\r\n\r\n  distances.set(startKey, 0);\r\n  pq.enqueue({ key: startKey, distance: 0 });\r\n\r\n  let found = false;\r\n  while (!pq.isEmpty()) {\r\n      const current = pq.dequeue();\r\n      console.log(`[处理节点] ${current.key} (当前距离: ${current.distance})`);\r\n      if (current.key === endKey) {\r\n          found = true;\r\n          break;\r\n      }\r\n      // 获取有效邻接节点\r\n      const neighbors = this.network.adjacencyList.get(current.key) || [];\r\n      console.log(`[邻接节点] ${current.key} 的邻居:`, neighbors.map(n => n.node));\r\n\r\n      neighbors.forEach(neighbor => {\r\n          const tentativeDistance = current.distance + neighbor.distance;\r\n          const currentDistance = distances.get(neighbor.node) || Infinity;\r\n\r\n          console.log(`[距离计算] ${current.key} -> ${neighbor.node}: \r\n              暂定 ${tentativeDistance} vs 当前 ${currentDistance}`);\r\n\r\n          if (tentativeDistance < currentDistance) {\r\n              console.log(`[更新节点] ${neighbor.node} 新距离: ${tentativeDistance}`);\r\n              \r\n              // 更新距离和前驱节点\r\n              distances.set(neighbor.node, tentativeDistance);\r\n              prev.set(neighbor.node, current.key);\r\n\r\n              // 优化入队逻辑：先删除旧值再插入新值\r\n              pq.enqueue({\r\n                  key: neighbor.node,\r\n                  distance: tentativeDistance\r\n              });\r\n          }\r\n      });\r\n  }\r\n\r\n\r\n  const path = [];\r\n    let currentKey = endKey;\r\n    let safetyCounter = 0;\r\n\r\n    // 新增前驱节点有效性验证\r\n    if (!prev.has(endKey)) {\r\n        console.error(`终点 ${endKey} 不可达`);\r\n        return [];\r\n    }\r\n\r\n    while (currentKey && safetyCounter < 1000) {\r\n        safetyCounter++;\r\n\r\n        // 验证节点存在性\r\n        if (!this.network.nodes.has(currentKey)) {\r\n            console.error(`无效节点 ${currentKey} 存在于路径中`);\r\n            return [];\r\n        }\r\n\r\n        path.unshift(this.network.nodes.get(currentKey));\r\n        currentKey = prev.get(currentKey);\r\n    }\r\n\r\n    // 验证路径完整性\r\n    if (path.length === 0 ||\r\n        path[0].x !== startNode.x || path[0].y !== startNode.y ||\r\n        path[path.length - 1].x !== endNode.x || path[path.length - 1].y !== endNode.y\r\n    ) {\r\n        console.error(\"路径不连贯，起始/终点不匹配\");\r\n        console.error(\"实际路径起点:\", path[0]?.x, path[0]?.y);\r\n        console.error(\"预期路径起点:\", startNode.x, startNode.y);\r\n        return [];\r\n    }\r\n\r\n    // 返回反转后的正确路径\r\n    return path.reverse();\r\n}\r\n\r\n// 新增调试方法\r\n_debugPrintPath(prev, startKey, endKey) {\r\n  console.groupCollapsed(\"[调试] 前驱节点映射\");\r\n  let current = endKey;\r\n  const path = [];\r\n  while (current) {\r\n      path.unshift(current);\r\n      current = prev.get(current);\r\n      if (path.includes(current)) {\r\n          console.log(\"发现循环:\", current);\r\n          break;\r\n      }\r\n  }\r\n  console.log(\"重构尝试路径:\", path);\r\n  console.groupEnd();\r\n}\r\n\r\n\r\n  _resolveActualPath(nodePath) {\r\n    if (!nodePath || nodePath.length < 2) return [];\r\n    \r\n    const fullPath = [];\r\n    try {\r\n      for (let i = 0; i < nodePath.length - 1; i++) {\r\n        const edgeKey = this.network._edgeKey(nodePath[i], nodePath[i+1]);\r\n        const edge = this.network.edges.get(edgeKey);\r\n        \r\n        if (edge && edge.path) {\r\n          fullPath.push(...edge.path);\r\n        }\r\n      }\r\n    } catch (e) {\r\n      console.error('路径解析错误:', e);\r\n      return [];\r\n    }\r\n    return fullPath;\r\n  }\r\n\r\n  // 修改后的楼层切换方法\r\n  loadSecondFloor() {\r\n    this.vm.currentFloor = '二楼';\r\n    this.vm.blockX = 0;\r\n    this.vm.blockY = 0;\r\n    this.vm.pathEnd = null;\r\n    this.currentPath = [];\r\n    this._buildShopNetwork(); \r\n    this.drawAllElements();\r\n  }\r\n\r\n\r\n  drawPath() {\r\n    if (this.currentPath.length === 0) return;\r\n  \r\n    const { ctx, vm: { gridSize, pathStart, pathEnd } } = this;\r\n    ctx.beginPath();\r\n    ctx.strokeStyle = '#ff0000';\r\n    ctx.lineWidth = 2;\r\n  \r\n    // 绘制起点到临近节点的连线\r\n    if (pathStart) {\r\n      const startNode = this._findNearestNetworkNode(pathStart);\r\n      if (startNode) {\r\n        const startX = (pathStart.x + 0.5) * gridSize;\r\n        const startY = (pathStart.y + 0.5) * gridSize;\r\n        const nodeX = (startNode.x + 0.5) * gridSize;\r\n        const nodeY = (startNode.y + 0.5) * gridSize;\r\n        ctx.moveTo(startX, startY);\r\n        ctx.lineTo(nodeX, nodeY);\r\n      }\r\n    }\r\n\r\n    // 绘制路径\r\n    this.currentPath.forEach((point, index) => {\r\n      const x = (point.x + 0.5) * gridSize;\r\n      const y = (point.y + 0.5) * gridSize;\r\n      index === 0 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);\r\n    });\r\n\r\n    // 绘制终点到临近节点的连线\r\n    if (pathEnd) {\r\n      const endNode = this._findNearestNetworkNode(pathEnd);\r\n      if (endNode) {\r\n        const endX = (pathEnd.x + 0.5) * gridSize;\r\n        const endY = (pathEnd.y + 0.5) * gridSize;\r\n        const nodeX = (endNode.x + 0.5) * gridSize;\r\n        const nodeY = (endNode.y + 0.5) * gridSize;\r\n        ctx.moveTo(endX, endY);\r\n        ctx.lineTo(nodeX, nodeY);\r\n      }\r\n    }\r\n\r\n    ctx.stroke();\r\n  }\r\n\r\n  drawColoredGrid(x, y, color) {\r\n    const gridSize = this.vm.gridSize;\r\n    const startX = x * gridSize;\r\n    const startY = y * gridSize;\r\n    this.ctx.fillStyle = color;\r\n    this.ctx.fillRect(startX, startY, gridSize, gridSize);\r\n  }\r\n\r\n  drawGrid() {\r\n    const { ctx, vm: { gridSize, canvasWidth, canvasHeight } } = this;\r\n    ctx.strokeStyle = 'gray';\r\n    ctx.lineWidth = 1;\r\n\r\n    // 绘制横向网格线\r\n    for (let y = 0; y <= canvasHeight; y += gridSize) {\r\n      ctx.beginPath();\r\n      ctx.moveTo(0, y);\r\n      ctx.lineTo(canvasWidth, y);\r\n      ctx.stroke();\r\n    }\r\n\r\n    // 绘制纵向网格线\r\n    for (let x = 0; x <= canvasWidth; x += gridSize) {\r\n      ctx.beginPath();\r\n      ctx.moveTo(x, 0);\r\n      ctx.lineTo(x, canvasHeight);\r\n      ctx.stroke();\r\n    }\r\n  }\r\n\r\n  \r\n\r\n  loadFirstFloor () {\r\n    this.vm.currentFloor = '一楼';\r\n    this.vm.blockX = 0;\r\n    this.vm.blockY = 0;\r\n    this.vm.pathEnd = null;\r\n    this.currentPath = [];\r\n    this._buildShopNetwork(); \r\n    this.drawAllElements();\r\n  };\r\n\r\n  drawAllElements() {\r\n    const { ctx, vm } = this;\r\n    ctx.clearRect(0, 0, vm.canvasWidth, vm.canvasHeight);\r\n    \r\n    this.drawGrid();\r\n    this.drawShops();\r\n    this.drawWalls() ;\r\n    this.drawObstacles();\r\n    this.drawPlayer();\r\n    this.drawPath();\r\n    //this.drawNetwork();\r\n\r\n    if (vm.pathStart) {\r\n      this.drawColoredGrid(vm.pathStart.x, vm.pathStart.y, 'blue');\r\n    }\r\n    if (vm.pathEnd) {\r\n      this.drawColoredGrid(vm.pathEnd.x, vm.pathEnd.y, 'red');\r\n    }\r\n    \r\n    this.animationFrame = requestAnimationFrame(() => this.drawAllElements());\r\n  }\r\n\r\n  drawShops() {\r\n    const { currentFloorShops: shops, gridSize } = this.vm;\r\n    const { ctx } = this;\r\n    \r\n    shops.forEach(shop => {\r\n      drawShapes[shop.shape](ctx, shop, gridSize);\r\n      \r\n      ctx.save();\r\n      ctx.fillStyle = '#ffffff';\r\n      ctx.font = `${Math.round(gridSize/2)}px Arial`; \r\n      ctx.textAlign = \"center\";\r\n      ctx.textBaseline = \"middle\";\r\n      \r\n      const textX = (shop.x + shop.width/2) * gridSize;\r\n      const textY = (shop.y + shop.height/2) * gridSize;\r\n      \r\n      ctx.strokeStyle = '#000000';\r\n      ctx.lineWidth = 2;\r\n      ctx.strokeText(shop.shopName, textX, textY);\r\n      \r\n      ctx.fillText(shop.shopName, textX, textY);\r\n      ctx.restore(); \r\n    });\r\n  }\r\n\r\n  drawObstacles() {\r\n    const { currentFloorObstacles: obstacles, gridSize, treeImage } = this.vm;\r\n    obstacles.forEach(obs => {\r\n      if (treeImage.complete) {\r\n        this.ctx.drawImage(treeImage, obs.x * gridSize, obs.y * gridSize, gridSize, gridSize);\r\n      }\r\n    });\r\n  }\r\n  drawWalls() {\r\n    const { ctx, vm: { gridSize, currentFloorWalls } } = this;    \r\n    ctx.fillStyle = '#666666'; \r\n    \r\n    ctx.strokeStyle = '#444444';\r\n    ctx.lineWidth = 10;\r\n\r\n    currentFloorWalls.forEach(wall => {\r\n      const startX = wall.startX * gridSize;\r\n      const startY = wall.startY * gridSize;\r\n      const endX = wall.endX * gridSize;\r\n      const endY = wall.endY * gridSize;\r\n\r\n      ctx.beginPath();\r\n      ctx.moveTo(startX, startY);\r\n      ctx.lineTo(endX, endY);\r\n      ctx.stroke();\r\n    });\r\n  }\r\n  \r\n  drawNetwork() {\r\n    const { ctx, vm: { gridSize } } = this;\r\n    \r\n    // 绘制节点\r\n    ctx.fillStyle = 'blue';\r\n    this.network.nodes.forEach(node => {\r\n        ctx.beginPath();\r\n        ctx.arc(\r\n            (node.x + 0.5) * gridSize,\r\n            (node.y + 0.5) * gridSize,\r\n            3, 0, Math.PI * 2\r\n        );\r\n        ctx.fill();\r\n    });\r\n\r\n    // 绘制连接线和距离\r\n    ctx.strokeStyle = 'rgba(0,0,255,0.3)';\r\n    ctx.font = '10px Arial';\r\n    ctx.fillStyle = 'black';\r\n    this.network.edges.forEach((edge, key) => {\r\n        const [from, to] = key.split('-').map(k => {\r\n            const [x, y] = k.split(',').map(Number);\r\n            return { x, y };\r\n        });\r\n        \r\n        ctx.beginPath();\r\n        ctx.moveTo((from.x + 0.5) * gridSize, (from.y + 0.5) * gridSize);\r\n        ctx.lineTo((to.x + 0.5) * gridSize, (to.y + 0.5) * gridSize);\r\n        ctx.stroke();\r\n\r\n        // 计算边的中间位置\r\n        const midX = ((from.x + to.x) / 2 + 0.5) * gridSize;\r\n        const midY = ((from.y + to.y) / 2 + 0.5) * gridSize;\r\n\r\n        // 绘制边的距离\r\n        ctx.fillText(edge.distance, midX, midY);\r\n    });\r\n}    \r\n\r\n  drawPlayer() {\r\n    const { ctx, vm: { blockX, blockY, gridSize } } = this;\r\n    ctx.fillStyle = 'red';\r\n    ctx.fillRect(blockX * gridSize, blockY * gridSize, gridSize, gridSize);\r\n  }\r\n\r\n  destroy() {\r\n    cancelAnimationFrame(this.animationFrame);\r\n  }\r\n}\r\nclass PriorityQueue {\r\n  constructor(compare) {\r\n    this.elements = [];\r\n    this.compare = compare; \r\n    // 使用Map记录节点索引提升性能\r\n    this.nodeIndices = new Map(); \r\n  }\r\n\r\n  enqueue(element) {\r\n    // 移除旧条目\r\n    if (this.nodeIndices.has(element.key)) {\r\n      const index = this.nodeIndices.get(element.key);\r\n      this.elements.splice(index, 1);\r\n    }\r\n    \r\n    // 二分查找插入\r\n    let low = 0, high = this.elements.length;\r\n    while (low < high) {\r\n      const mid = (low + high) >>> 1;\r\n      if (this.compare(element, this.elements[mid])) {\r\n        high = mid;\r\n      } else {\r\n        low = mid + 1;\r\n      }\r\n    }\r\n    \r\n    this.elements.splice(low, 0, element);\r\n    // 更新所有节点的索引（此处可以优化为只更新受影响的部分）\r\n    this._rebuildIndices();\r\n  }\r\n\r\n  dequeue() {\r\n    const element = this.elements.shift();\r\n    this._rebuildIndices();\r\n    return element;\r\n  }\r\n\r\n  _rebuildIndices() {\r\n    this.nodeIndices.clear();\r\n    this.elements.forEach((el, index) => {\r\n      this.nodeIndices.set(el.key, index);\r\n    });\r\n  }\r\n\r\n  isEmpty() {\r\n    return this.elements.length === 0;\r\n  }\r\n}"]},"metadata":{},"sourceType":"module"}